2016Jul18 - dvillen
=The tail recursion test introduce two new features:
    a IF-THEN-ELSE pattern
    a means to define recursion

The IF-THEN-ELSE pattern can be used on its own.
However the recursion must use the IF-THEN-ELSE pattern.
Obviously users can always implement in the OCR C code
their own if-then-else and recursion.
But, by formalizing the IF-THEN-ELSE pattern and recursion, they become part
of the autogen graph, and thereby can be verified and managed explicitly.

=The file "y_tailRecursion_with_Work.dot.png" is the image of the autogen|OCR graph.
Its DOT file can be generated by enabling the appropriate switch in "TailRecursion.py",
and rerunning it.

The user side C code not related to OCR is contained in the files "tailrecursion.(h|c)"
The autogen code for the tail recursion is in "TailRecursion.py".  It is run as follows:
    python TailRecursion.py
assuming that the Python library "NetworkX" has been installed.
"TailRecursion.py" will typically generate a C file called "z_tailRecursion.c"
containing the OCR code.

=In order for the IF-THEN-ELSE pattern to work, the following must be done:
    1)The user must provide 3 functions:
        - bool condition(...)
        - Err_t trueClause(...)
        - Err_t falseClause(...)

        The names and returned types of these functions are not critical, as long
        as the autogen script as been correspondingly coded.  Only the condition(...)
        function MUST return a type convertible to a boolean.

    2)The EDT holding the IF-THEN part must have its condition clause defined, e.g.
            OA.addIFconditionText(G,nc,iterConditionText)
      and its THEN body should have something of the sort:
            OA.addCustomText(G, nc, text_for_THEN_clause)

    3) A separate EDT is used to model the ELSE part.  And it should have its body
       code defined:
            OA.addCustomText(G, nc, text_for_ELSE_clause)

    4) The IF-THEN EDT must be connected through a NULL_GUID data block to the ELSE EDT.
       Furthermore the edge between these two must be clearly identified
       as the link between the IF-THEN edt and the ELSE edt.  For example:
            ledg=OA.graphAddEdge(G, "Iteration", "IterationElse", "NULL_GUID")
            OA.getEdge(G, ledg[0])["leads_to_ElseClause"] = True
        Note the use of the raw edge tuple "ledg[0]" and not the labeled edge.

=In order for the Recursion part to be properly identified, one must specify which edge of
the graph is the reentrant edge.  Consider:

    A--> B --> C --> D
         ^     |
         |     |
         -------

The edge A-->B is the main entry edge.  The edge C-->B is the reentrant edge, who will be
using the same slots as the edge A-->B.  Autogen will check that both edge behaves identically.
In "TailRecursion.py", this identification is done as follows:

    A) Record the edge tuple of the main input edge:
            ledg=OA.graphAddEdge(G, "SetupIteration", "Iteration", "Work")
            main_iteration_input_edge=ledg[0]

    B) Use "main_iteration_input_edge" when defined the reentrant edge:
            ledg=OA.graphAddEdge(G, "Iteration", "Iteration", "Iterate")
            OA.sharedConx(G,ledg[0]).append(main_iteration_input_edge)

The same must be done for each edge|data blocks, as is the case for the "Work" data block.

=The test script "btest" assumes that the command " OCR_TYPE=x86-mpi make run" can be successfully run.
 If so, the black box test "btest" creates a reference file "z_ref_output" which is what we expect the code to output.
 It then proceed to autogen the OCR code, run it and compare its output to the reference file.
 Upon success, zero is returned; otherwise whatever caused an error is returned.





