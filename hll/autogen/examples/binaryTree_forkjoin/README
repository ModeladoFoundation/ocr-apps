2016Aug23 - dvillen
=The binaryTree_forkjoin builds upon the tailRecusrion example.
 It introduce the
    a FOR pattern

The FOR pattern is used to get an EDT to emit multiple EDTs using a C for loop.
By making the FOR pattern explicit in autogen, one can parametrized the one-to-many
relationship.

=The file "y_bintree_forkjoin.dot.png" is the image of the autogen|OCR graph.
 Its DOT file can be generated by enabling the appropriate switch in "bintree_forkjoin.py",
 and rerunning it.

= The file "y_bintree_forkjoin3_runtime.dot.png" was build by post-processing the raw
  output from autogen.
  1) One must set
    "OA.GBL.insert_debug_code = 1"
    in the autogen file "bintree_forkjoin.py"
  2) The OCR build setup "CONFIG_FLAGS=--guid=COUNTED_MAP" must be set.
     See the black box test file "btest" for details.
     Also note that disabling "rm -f z*", in "btest", might be useful.
  3) Assuming the raw output from autogen is piped into "z_log", then doing
        "python ../../tools/ocr_autogen_dbg_postproc.py -i z_log -o z_out.dot"
     will output

  Note: For this to work properly, each GUID used by OCR must be unique; and
        the OCR function "currentEdtUserGet" should work.
  Note: Setting "OA.GBL.insert_debug_code" will cause the auto-generated code
        to be tooled with many new PRINTFs, and auxiliary commands.
        That is how the raw log gets the information.

= The FOR pattern is implemented by using the command "OA.addFORconditionText".
  The autogen file "bintree_forkjoin.py" contains an example of its usage.
  Also any data block incident on an EDT with a FOR pattern may need to have its
  destruction delayed until after the for loop.
  The data block command "delayReleaseDestroy" has been introduced to that effect.

=The test script "btest" assumes that the command " OCR_TYPE=x86-mpi make run" can be successfully run.
 If so, the black box test "btest" creates a reference file "z_ref_output" which is what we expect the code to output.
 It then proceed to autogen the OCR code, run it and compare its output to the reference file.
 Upon success, zero is returned; otherwise whatever caused an error is returned.

=In the current implementation, the binary tree forking is done by splitting an interval in two parts, until
 the low and high end of the interval are equal.
 The C code provided handles the book-keeping required, while the autogen code provides the production and
 routing of EDTs and DBKs.

 An integer BTIndex is used to keep track of the fork tree, and also how close one is to the exit when joining.









