/* Auto-generated by R-Stream without advanced optimizations */

#include <rstream_ocr.h>
#include <ocr.h>
union ocrGuidUnion_t;
struct ocrEdtDepStruct_t;
struct __anon_21;
union __args_mv1_22;
union ocrGuidUnion_t;
struct ocrEdtDepStruct_t;
struct __anon_23;
union __args_mv2_24;
union ocrGuidUnion_t;
struct ocrEdtDepStruct_t;
struct __anon_25;
union __args_mv_main_26;
union ocrGuidUnion_t;
struct __anon_21 {
   float* C;
   float (* A)[2000];
   float* E;
   int IT0;
   int IT1;
};
union __args_mv1_22 {
   struct __anon_21 data;
   double padding[4];
};
struct __anon_23 {
   float* B;
   float (* A)[2000];
   float* D;
   int IT0;
   int IT1;
};
union __args_mv2_24 {
   struct __anon_23 data;
   double padding[4];
};
struct __anon_25 {
   float* C;
   float (* A)[2000];
   float* E;
   float* B;
   float* D;
};
union __args_mv_main_26 {
   struct __anon_25 data;
   double padding[5];
};
/*
 * Forward declarations of functions
 */
void print_submatrix(char const*, void const*, int, int, int, int, int, int);
int check_matrices(char const*, char const*, void const*, void const*, int, int
   );
void initialize(void);
void initialize_once(void);
void show(void);
void kernel(void);
int check(void);
double flops_per_trial(void);
void mv(float (* A)[2000], float* B, float* C, float* D, float* E);
static ocrGuid_t mv1(unsigned int paramc, unsigned long* paramv, unsigned int 
   depc, ocrEdtDep_t* depv);
void* rocrArgs(ocrEdtDep_t*);
static ocrGuid_t mv2(unsigned int paramc, unsigned long* paramv, unsigned int 
   depc, ocrEdtDep_t* depv);
void x86_dma_get(void const volatile*, void volatile*, unsigned long, long, 
   long, unsigned long, int);
void x86_dma_wait(int);
void x86_dma_put(void const volatile*, void volatile*, unsigned long, long, 
   long, unsigned long, int);
static ocrGuid_t mv_main(unsigned int paramc, unsigned long* paramv, 
   unsigned int depc, ocrEdtDep_t* depv);
void rocrExit(void);
/*
 * Forward declarations of global variables
 */
extern int add_flop;
extern int mul_flop;
/* This can be redefined to be the appropriate 'inline' keyword */
#ifndef RSTREAM_INLINE
#define RSTREAM_INLINE
#endif
#ifdef GPU_TARGET
    #define __mins_32(x,y) \
 min((int)(x),(int)(y))
#else
static RSTREAM_INLINE int __mins_32(int x, int y) {
   return x < y ? x : y;
}
#endif
/*
 * Definitions of global variables
 */
extern int add_flop;
extern int mul_flop;
static float x1[2000];
static float x2[2000];
static float a[2000][2000];
static float y_1[2000];
static float y_2[2000];
static float Tx1[2000];
static float Tx2[2000];
static float Ta[2000][2000];
static float Ty_1[2000];
static float Ty_2[2000];
int nb_samples = 4000000;
char const* function_name = "mvt";
/*
 * Definitions of functions
 */
/*
 * ../src/mvt.c:52.6
 */
void initialize(void)
{
   double _t1;
   int i;
   int i_1;
   int i_2;
   for (i = 0, i_1 = 0, i_2 = 0; _t1 = (double)i * 0.5 + 2.3, i < 2000; i++, 
           i_1 += 0, i_2++) {
      float _t2;
      float* _t3;
      float* _t4;
      int j;
      int j_1;
      _t2 = (float)_t1;
      Tx2[i] = _t2;
      Tx1[i] = _t2;
      x2[i] = _t2;
      x1[i] = _t2;
      Ty_2[i] = _t2;
      Ty_1[i] = _t2;
      y_2[i] = _t2;
      _t3 = a[i];
      _t4 = Ta[i];
      y_1[i] = _t2;
      for (j = 0, j_1 = i_1; j < 2000; j++, j_1 += i_2) {
         float _t5;
         _t5 = (float)j_1 * 0.5f + 2.299999952f;
         _t4[j] = _t5;
         _t3[j] = _t5;
      }
   }
}

/*
 * ../src/mvt.c:65.6
 */
void initialize_once(void)
{
   initialize();
}

/*
 * ../src/mvt.c:69.6
 */
void show(void)
{
   void const* _t1;
   _t1 = a;
   print_submatrix("a", _t1, 2000, 2000, 0, 8, 0, 8);
   print_submatrix("a", _t1, 2000, 2000, 1992, 2000, 1992, 2000);
}

/*
 * ../src/mvt.c:78.6
 */
void kernel(void)
{
   union __args_mv_main_26* allArgs;
   ocrGuid_t _t1;
   union __args_mv_main_26* _t2;
   rocrDeclareType(mv_main, 2, (unsigned int)1, 1);
   rocrDeclareType(mv1, 0, (unsigned int)32, 0);
   rocrDeclareType(mv2, 1, (unsigned int)32, 0);
   rocrInit();
   _t1 = rocrAlloc((void**)&allArgs, 40ul);
   _t2 = allArgs;
   _t2->data.C = x2;
   _t2->data.A = a;
   _t2->data.E = y_2;
   _t2->data.B = x1;
   _t2->data.D = y_1;
   rocrExecute(2, _t1);
   rocrExit();
}

/*
 * ../src/mvt.c:82.5
 */
int check(void)
{
   int i;
   int i_1;
   for (i = 0; i < 2000; i++) {
      float* _t1;
      float* _t2;
      int j;
      for (_t2 = Ta[i], _t1 = Tx1 + i, j = 0; j < 2000; j++) {
         *_t1 = *_t1 + _t2[j] * Ty_1[j];
      }
   }
   for (i_1 = 0; i_1 < 2000; i_1++) {
      float* _t3;
      int j;
      for (_t3 = Tx2 + i_1, j = 0; j < 2000; j++) {
         *_t3 = *_t3 + Ta[j][i_1] * Ty_2[j];
      }
   }
   return check_matrices("a", "Ta", a, Ta, 2000, 2000);
}

/*
 * ../src/mvt.c:89.8
 */
double flops_per_trial(void)
{
   return (double)(mul_flop + add_flop) * 2.0 * 2000.0 * 2000.0;
}

void mv(float (* A)[2000], float* B, float* C, float* D, float* E)
{
   union __args_mv_main_26* allArgs;
   ocrGuid_t _t1;
   union __args_mv_main_26* _t2;
   rocrDeclareType(mv_main, 2, (unsigned int)1, 1);
   rocrDeclareType(mv1, 0, (unsigned int)32, 0);
   rocrDeclareType(mv2, 1, (unsigned int)32, 0);
   rocrInit();
   _t1 = rocrAlloc((void**)&allArgs, 40ul);
   _t2 = allArgs;
   _t2->data.C = C;
   _t2->data.A = A;
   _t2->data.E = E;
   _t2->data.B = B;
   _t2->data.D = D;
   rocrExecute(2, _t1);
   rocrExit();
}

static ocrGuid_t mv1(unsigned int paramc, unsigned long* paramv, unsigned int 
   depc, ocrEdtDep_t* depv)
{
   union __args_mv1_22 mv1_args;
   float* C_l;
   float (* A_l)[64];
   float* E_l;
   float* C;
   int IT0;
   ocrGuid_t _t1;
   ocrGuid_t _t2;
   ocrGuid_t _t3;
   int _t4;
   int i;
   mv1_args = *(union __args_mv1_22*)rocrArgs(depv);
   _t1 = rocrAlloc((void**)&C_l, 256ul);
   _t2 = rocrAlloc((void**)&A_l, 512000ul);
   _t3 = rocrAlloc((void**)&E_l, 8000ul);
   IT0 = mv1_args.data.IT0;
   C = mv1_args.data.C;
   x86_dma_get(C + (64 * IT0 + 0), C_l + 0, (unsigned long)(unsigned int)((
      __mins_32(-64 * IT0 + 2000, 64)) * 4), (long)0, (long)0, (unsigned long)(
      unsigned int)1, 0);
   x86_dma_get(mv1_args.data.A[0] + (64 * IT0 + 0), A_l[0] + 0, (unsigned long)
      (unsigned int)((__mins_32(-64 * IT0 + 2000, 64)) * 4), (long)8000, (long)
      256, (unsigned long)(unsigned int)2000, 0);
   x86_dma_get(mv1_args.data.E + 0, E_l + 0, (unsigned long)(unsigned int)8000,
       (long)0, (long)0, (unsigned long)(unsigned int)1, 0);
   _t4 = (__mins_32(-64 * IT0 + 1999, 63));
   x86_dma_wait(0);
   for (i = 0; i <= _t4; i++) {
      int j;
      for (j = 0; j <= 1999; j++) {
         C_l[i] = C_l[i] + A_l[j][i] * E_l[j];
      }
   }
   x86_dma_put(C_l + 0, C + (64 * IT0 + 0), (unsigned long)(unsigned int)((
      __mins_32(-64 * IT0 + 2000, 64)) * 4), (long)0, (long)0, (unsigned long)(
      unsigned int)1, 1);
   x86_dma_wait(1);
   ocrDbDestroy(_t1);
   ocrDbDestroy(_t2);
   ocrDbDestroy(_t3);
   return NULL_GUID;
}

static ocrGuid_t mv2(unsigned int paramc, unsigned long* paramv, unsigned int 
   depc, ocrEdtDep_t* depv)
{
   union __args_mv2_24 mv2_args;
   float* B_l;
   float (* A_l_1)[2000];
   float* D_l;
   float* B;
   int IT0;
   ocrGuid_t _t1;
   ocrGuid_t _t2;
   ocrGuid_t _t3;
   int _t4;
   int i;
   mv2_args = *(union __args_mv2_24*)rocrArgs(depv);
   _t1 = rocrAlloc((void**)&B_l, 256ul);
   _t2 = rocrAlloc((void**)&A_l_1, 512000ul);
   _t3 = rocrAlloc((void**)&D_l, 8000ul);
   IT0 = mv2_args.data.IT0;
   B = mv2_args.data.B;
   x86_dma_get(B + (64 * IT0 + 0), B_l + 0, (unsigned long)(unsigned int)((
      __mins_32(-64 * IT0 + 2000, 64)) * 4), (long)0, (long)0, (unsigned long)(
      unsigned int)1, 0);
   x86_dma_get(mv2_args.data.A[64 * IT0 + 0] + 0, A_l_1[0] + 0, (unsigned long)
      (unsigned int)8000, (long)8000, (long)8000, (unsigned long)(unsigned int)
      (__mins_32(-64 * IT0 + 2000, 64)), 0);
   x86_dma_get(mv2_args.data.D + 0, D_l + 0, (unsigned long)(unsigned int)8000,
       (long)0, (long)0, (unsigned long)(unsigned int)1, 0);
   _t4 = (__mins_32(-64 * IT0 + 1999, 63));
   x86_dma_wait(0);
   for (i = 0; i <= _t4; i++) {
      int j;
      for (j = 0; j <= 1999; j++) {
         B_l[i] = B_l[i] + A_l_1[i][j] * D_l[j];
      }
   }
   x86_dma_put(B_l + 0, B + (64 * IT0 + 0), (unsigned long)(unsigned int)((
      __mins_32(-64 * IT0 + 2000, 64)) * 4), (long)0, (long)0, (unsigned long)(
      unsigned int)1, 1);
   x86_dma_wait(1);
   ocrDbDestroy(_t1);
   ocrDbDestroy(_t2);
   ocrDbDestroy(_t3);
   return NULL_GUID;
}

static ocrGuid_t mv_main(unsigned int paramc, unsigned long* paramv, 
   unsigned int depc, ocrEdtDep_t* depv)
{
   union __args_mv_main_26 mv_main_args;
   union __args_mv1_22* allArgs;
   union __args_mv2_24* allArgs_1;
   float (* A)[2000];
   float* B;
   float* D;
   float* C;
   float* E;
   int i;
   int i_1;
   for (mv_main_args = *(union __args_mv_main_26*)rocrArgs(depv),
        D = mv_main_args.data.D,
        B = mv_main_args.data.B,
        E = mv_main_args.data.E,
        A = mv_main_args.data.A,
        C = mv_main_args.data.C,
        i = 0;
        i <= 31; i++) {
      ocrGuid_t _t1;
      union __args_mv1_22* _t2;
      _t1 = rocrAlloc((void**)&allArgs, 32ul);
      _t2 = allArgs;
      _t2->data.C = C;
      _t2->data.A = A;
      _t2->data.E = E;
      _t2->data.IT0 = i;
      _t2->data.IT1 = 0;
      rocrDeclareTask(0, _t1, (unsigned int)i);
   }
   for (i_1 = 0; i_1 <= 31; i_1++) {
      ocrGuid_t _t3;
      union __args_mv2_24* _t4;
      _t3 = rocrAlloc((void**)&allArgs_1, 32ul);
      _t4 = allArgs_1;
      _t4->data.B = B;
      _t4->data.A = A;
      _t4->data.D = D;
      _t4->data.IT0 = i_1;
      _t4->data.IT1 = 0;
      rocrDeclareTask(1, _t3, (unsigned int)i_1);
   }
   rocrScheduleAll();
   return NULL_GUID;
}

