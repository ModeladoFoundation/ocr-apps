/* Auto-generated by R-Stream without advanced optimizations */

#include <rstream_ocr.h>
#include <ocr.h>
struct _IO_FILE;
union ocrGuidUnion_t;
struct ocrEdtDepStruct_t;
struct __anon_21;
union __args_fd1_22;
union ocrGuidUnion_t;
struct ocrEdtDepStruct_t;
struct __anon_23;
union __args_fd_main_24;
union ocrGuidUnion_t;
struct _IO_marker;
struct _IO_FILE {
   int _flags;
   char* _IO_read_ptr;
   char* _IO_read_end;
   char* _IO_read_base;
   char* _IO_write_base;
   char* _IO_write_ptr;
   char* _IO_write_end;
   char* _IO_buf_base;
   char* _IO_buf_end;
   char* _IO_save_base;
   char* _IO_backup_base;
   char* _IO_save_end;
   struct _IO_marker* _markers;
   struct _IO_FILE* _chain;
   int _fileno;
   int _flags2;
   long _old_offset;
   unsigned short _cur_column;
   signed char _vtable_offset;
   char _shortbuf[1];
   void* _lock;
   long _offset;
   void* __pad1;
   void* __pad2;
   void* __pad3;
   void* __pad4;
   unsigned long __pad5;
   int _mode;
   char _unused2[20];
};
struct __anon_21 {
   float* A;
   float* B;
   int IT0;
   int IT1;
};
union __args_fd1_22 {
   struct __anon_21 data;
   double padding[3];
};
struct __anon_23 {
   float* A;
   float* B;
};
union __args_fd_main_24 {
   struct __anon_23 data;
   double padding[2];
};
struct _IO_marker {
   struct _IO_marker* _next;
   struct _IO_FILE* _sbuf;
   int _pos;
};
/*
 * Forward declarations of functions
 */
int check_vectors(char const*, char const*, void const*, void const*, int);
int fprintf(struct _IO_FILE*, char const*, ...);
void initialize(void);
void initialize_once(void);
void show(void);
void kernel(void);
int check(void);
double flops_per_trial(void);
void fd(float* A, float* B);
static ocrGuid_t fd1(unsigned int paramc, unsigned long* paramv, unsigned int
   depc, ocrEdtDep_t* depv);
void* rocrArgs(ocrEdtDep_t*);
void x86_dma_get(void const volatile*, void volatile*, unsigned long, long,
   long, unsigned long, int);
void x86_dma_wait(int);
void x86_dma_put(void const volatile*, void volatile*, unsigned long, long,
   long, unsigned long, int);
static ocrGuid_t fd_main(unsigned int paramc, unsigned long* paramv,
   unsigned int depc, ocrEdtDep_t* depv);
void rocrExit(void);
/*
 * Forward declarations of global variables
 */
extern int add_flop;
extern int mul_flop;
extern struct _IO_FILE* stderr;
/* This can be redefined to be the appropriate 'inline' keyword */
#ifndef RSTREAM_INLINE
#define RSTREAM_INLINE
#endif
#ifdef GPU_TARGET
    #define __maxs_32(x,y) \
 max((int)(x),(int)(y))
#else
static RSTREAM_INLINE int __maxs_32(int x, int y) {
   return x > y ? x : y;
}
#endif
#ifdef GPU_TARGET
    #define __mins_32(x,y) \
 min((int)(x),(int)(y))
#else
static RSTREAM_INLINE int __mins_32(int x, int y) {
   return x < y ? x : y;
}
#endif
/*
 * Definitions of global variables
 */
extern int add_flop;
extern int mul_flop;
extern struct _IO_FILE* stderr;
static float e[5000];
static float h[5000];
static float ee[5000];
static float hh[5000];
int nb_samples = 25000000;
char const* function_name = "fdtd1d";
/*
 * Definitions of functions
 */
/*
 * ../src/fdtd1d.c:55.6
 */
void initialize(void)
{
   int i;
   for (i = 0; i < 5000; i++) {
      float _t1;
      float _t2;
      _t1 = (float)i;
      ee[i] = _t1;
      e[i] = _t1;
      _t2 = _t1 * 0.5f;
      hh[i] = _t2;
      h[i] = _t2;
   }
}

/*
 * ../src/fdtd1d.c:65.6
 */
void initialize_once(void)
{
   initialize();
}

/*
 * ../src/fdtd1d.c:69.6
 */
void show(void)
{
   int i;
   int i_1;
   for (i = 0; i < 8; i++) {
      fprintf(stderr, "e[%d] = %10.10f\n", i, (double)e[i]);
   }
   for (i_1 = 4992; i_1 < 5000; i_1++) {
      fprintf(stderr, "e[%d] = %10.10f\n", i_1, (double)e[i_1]);
   }
}

/*
 * ../src/fdtd1d.c:84.6
 */
void kernel(void)
{
   union __args_fd_main_24* allArgs;
   ocrGuid_t _t1;
   union __args_fd_main_24* _t2;
   rocrDeclareType(fd_main, 1, (unsigned int)1, 1);
   rocrDeclareType(fd1, 0, (unsigned int)49141, 0);
   rocrInit();
   _t1 = rocrAlloc((void**)&allArgs, 16ul);
   _t2 = allArgs;
   _t2->data.A = e;
   _t2->data.B = h;
   rocrExecute(1, _t1);
   rocrExit();
}

/*
 * ../src/fdtd1d.c:88.5
 */
int check(void)
{
   int t;
   for (t = 0; t < 5000; t++) {
      int i;
      int i_1;
      int i_2;
      for (i = 1, i_1 = 0; i < 4999; i++, i_1++) {
         ee[i] = ee[i] - 0.5f * (hh[i] - hh[i_1]);
      }
      for (i_2 = 0; i_2 < 4999; ) {
         int _t1;
         _t1 = i_2 + 1;
         hh[i_2] = hh[i_2] - 0.6999999881f * (ee[_t1] - ee[i_2]);
         i_2 = _t1;
      }
   }
   return check_vectors("e", "ee", e, ee, 5000);
}

/*
 * ../src/fdtd1d.c:95.8
 */
double flops_per_trial(void)
{
   return (double)(mul_flop + add_flop) * 2.0 * 5000.0 * 5000.0;
}

void fd(float* A, float* B)
{
   union __args_fd_main_24* allArgs;
   ocrGuid_t _t1;
   union __args_fd_main_24* _t2;
   rocrDeclareType(fd_main, 1, (unsigned int)1, 1);
   rocrDeclareType(fd1, 0, (unsigned int)49141, 0);
   rocrInit();
   _t1 = rocrAlloc((void**)&allArgs, 16ul);
   _t2 = allArgs;
   _t2->data.A = A;
   _t2->data.B = B;
   rocrExecute(1, _t1);
   rocrExit();
}

static ocrGuid_t fd1(unsigned int paramc, unsigned long* paramv, unsigned int
   depc, ocrEdtDep_t* depv)
{
   union __args_fd1_22 fd1_args;
   float* A_l;
   float* B_l;
   float* A;
   float* B;
   int IT0;
   int IT1;
   ocrGuid_t _t1;
   ocrGuid_t _t2;
   int _t3;
   int i;
   fd1_args = *(union __args_fd1_22*)rocrArgs(depv);
   _t1 = rocrAlloc((void**)&A_l, 320ul);
   _t2 = rocrAlloc((void**)&B_l, 320ul);
   IT1 = fd1_args.data.IT1;
   IT0 = fd1_args.data.IT0;
   A = fd1_args.data.A;
   x86_dma_get(A + ((__maxs_32(16 * IT0 + -4984, __maxs_32(16 * IT0 + -64 * IT1
      + 15, 0))) + -16 * IT0 + (64 * IT1 + -15)), A_l + (__maxs_32(16 * IT0 +
      -4984, __maxs_32(16 * IT0 + -64 * IT1 + 15, 0))), (unsigned long)(
      unsigned int)((__mins_32(__mins_32(-16 * IT0 + 5064, -16 * IT0 + 64 * IT1
      + 65), __mins_32(-64 * IT1 + 9999, __mins_32(80, 16 * IT0 + -64 * IT1 +
      5015)))) * 4), (long)0, (long)0, (unsigned long)(unsigned int)1, 0);
   B = fd1_args.data.B;
   x86_dma_get(B + ((__maxs_32(16 * IT0 + -4984, __maxs_32(16 * IT0 + -64 * IT1
      + 15, 0))) + -16 * IT0 + (64 * IT1 + -15)), B_l + (__maxs_32(16 * IT0 +
      -4984, __maxs_32(16 * IT0 + -64 * IT1 + 15, 0))), (unsigned long)(
      unsigned int)((__mins_32(__mins_32(-16 * IT0 + 5064, -16 * IT0 + 64 * IT1
      + 65), __mins_32(-64 * IT1 + 9998, __mins_32(80, 16 * IT0 + -64 * IT1 +
      5014)))) * 4), (long)0, (long)0, (unsigned long)(unsigned int)1, 0);
   x86_dma_wait(0);
   if (IT0 + -4 * IT1 == -313 && IT1 >= 79) {
      B_l[5] = B_l[5] - 0.6999999881f * (A_l[6] - A_l[5]);
   }
   for (_t3 = (__mins_32(-16 * IT0 + 4999, 15)), i = (__maxs_32(0, -16 * IT0 +
           64 * IT1 + -4997)); i <= _t3; i++) {
      int _t4;
      int j;
      for (_t4 = (__mins_32(63, i + 16 * IT0 + -64 * IT1 + 4997)), j = (
              __maxs_32(i + 16 * IT0 + -64 * IT1, 0)); j <= _t4; j++) {
         A_l[-1 * i + (j + 16)] = A_l[-1 * i + (j + 16)] - 0.5f * (B_l[-1 * i +
            (j + 16)] - B_l[-1 * i + (j + 15)]);
         B_l[-1 * i + (j + 15)] = B_l[-1 * i + (j + 15)] - 0.6999999881f * (A_l
            [-1 * i + (j + 16)] - A_l[-1 * i + (j + 15)]);
      }
      if (- i + -16 * IT0 + 64 * IT1 >= 4935) {
         B_l[16 * IT0 + (-64 * IT1 + 5013)] = B_l[16 * IT0 + (-64 * IT1 + 5013)
            ] - 0.6999999881f * (A_l[16 * IT0 + (-64 * IT1 + 5014)] - A_l[16 *
            IT0 + (-64 * IT1 + 5013)]);
      }
   }
   x86_dma_put(A_l + (__maxs_32(16 * IT0 + -4983, __maxs_32(16 * IT0 + -64 * IT1
      + 16, 1))), A + ((__maxs_32(16 * IT0 + -4983, __maxs_32(16 * IT0 + -64 *
      IT1 + 16, 1))) + -16 * IT0 + (64 * IT1 + -15)), (unsigned long)(
      unsigned int)((__mins_32(__mins_32(-16 * IT0 + 5063, -16 * IT0 + 64 * IT1
      + 64), __mins_32(-64 * IT1 + 9997, __mins_32(79, 16 * IT0 + -64 * IT1 +
      5013)))) * 4), (long)0, (long)0, (unsigned long)(unsigned int)1, 1);
   x86_dma_put(B_l + (__maxs_32(16 * IT0 + -4984, __maxs_32(16 * IT0 + -64 * IT1
      + 15, 0))), B + ((__maxs_32(16 * IT0 + -4984, __maxs_32(16 * IT0 + -64 *
      IT1 + 15, 0))) + -16 * IT0 + (64 * IT1 + -15)), (unsigned long)(
      unsigned int)((__mins_32(__mins_32(-16 * IT0 + 5063, -16 * IT0 + 64 * IT1
      + 64), __mins_32(-64 * IT1 + 9998, __mins_32(79, 16 * IT0 + -64 * IT1 +
      5014)))) * 4), (long)0, (long)0, (unsigned long)(unsigned int)1, 1);
   x86_dma_wait(1);
   ocrDbDestroy(_t1);
   ocrDbDestroy(_t2);
   return NULL_GUID;
}

static ocrGuid_t fd_main(unsigned int paramc, unsigned long* paramv,
   unsigned int depc, ocrEdtDep_t* depv)
{
   union __args_fd_main_24 fd_main_args;
   union __args_fd1_22* allArgs;
   float* A;
   float* B;
   int i;
   int i_1;
   for (fd_main_args = *(union __args_fd_main_24*)rocrArgs(depv),
        B = fd_main_args.data.B,
        A = fd_main_args.data.A,
        i = 0;
        i <= 312; i++) {
      int _t1;
      int j;
      for (_t1 = (__mins_32(156, i + 313 >> 2)), j = (__maxs_32(i + -3 + 3 >> 2
              , 0)); j <= _t1; j++) {
         ocrGuid_t _t2;
         union __args_fd1_22* _t3;
         _t2 = rocrAlloc((void**)&allArgs, 24ul);
         _t3 = allArgs;
         _t3->data.A = A;
         _t3->data.B = B;
         _t3->data.IT0 = i;
         _t3->data.IT1 = j;
         rocrDeclareTask(0, _t2, (unsigned int)(j + 157 * i));
      }
   }
   for (i_1 = 0; i_1 <= 312; i_1++) {
      int _t4;
      int j;
      for (_t4 = (__mins_32(- i_1 + 467, i_1 + 313 >> 2)), j = (__maxs_32(i_1 +
              -3 + 3 >> 2, 0)); j <= _t4; j++) {
         int _t5;
         int k;
         for (_t5 = (__mins_32(312, __mins_32(i_1 + 1, (4 * i_1 + 4 * j + 7) / 5
                 ))), k = (__maxs_32((4 * i_1 + 4 * j + -309 + 4) / 5,
                 __maxs_32(i_1 + j + -155, i_1))); k <= _t5; k++) {
            rocrDeclareDependence(0, (unsigned int)(j + 157 * i_1), 0, (
               unsigned int)(i_1 + j + (-1 * k + 1) + 157 * k));
         }
      }
   }
   rocrScheduleAll();
   return NULL_GUID;
}

