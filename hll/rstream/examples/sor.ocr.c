/* Auto-generated by R-Stream without advanced optimizations */

#include <rstream_ocr.h>
#include <ocr.h>
union ocrGuidUnion_t;
struct ocrEdtDepStruct_t;
struct __anon_21;
union __args_so1_22;
union ocrGuidUnion_t;
struct ocrEdtDepStruct_t;
struct __anon_23;
union __args_so_main_24;
union ocrGuidUnion_t;
struct __anon_21 {
   float (* A)[10000];
   int IT0;
   int IT1;
};
union __args_so1_22 {
   struct __anon_21 data;
   double padding[2];
};
struct __anon_23 {
   float (* A)[10000];
};
union __args_so_main_24 {
   struct __anon_23 data;
   double padding[1];
};
/*
 * Forward declarations of functions
 */
void print_submatrix(char const*, void const*, int, int, int, int, int, int);
int check_matrices(char const*, char const*, void const*, void const*, int, int
   );
void initialize(void);
void initialize_once(void);
void show(void);
void kernel(void);
int check(void);
double flops_per_trial(void);
void so(float (* A)[10000]);
static ocrGuid_t so1(unsigned int paramc, unsigned long* paramv, unsigned int
   depc, ocrEdtDep_t* depv);
void* rocrArgs(ocrEdtDep_t*);
void x86_dma_get(void const volatile*, void volatile*, unsigned long, long,
   long, unsigned long, int);
void x86_dma_wait(int);
void x86_dma_put(void const volatile*, void volatile*, unsigned long, long,
   long, unsigned long, int);
static ocrGuid_t so_main(unsigned int paramc, unsigned long* paramv,
   unsigned int depc, ocrEdtDep_t* depv);
void rocrExit(void);
/*
 * Forward declarations of global variables
 */
extern int add_flop;
extern int mul_flop;
/* This can be redefined to be the appropriate 'inline' keyword */
#ifndef RSTREAM_INLINE
#define RSTREAM_INLINE
#endif
#ifdef GPU_TARGET
    #define __maxs_32(x,y) \
 max((int)(x),(int)(y))
#else
static RSTREAM_INLINE int __maxs_32(int x, int y) {
   return x > y ? x : y;
}
#endif
#ifdef GPU_TARGET
    #define __mins_32(x,y) \
 min((int)(x),(int)(y))
#else
static RSTREAM_INLINE int __mins_32(int x, int y) {
   return x < y ? x : y;
}
#endif
/*
 * Definitions of global variables
 */
extern int add_flop;
extern int mul_flop;
static float P[10000][10000];
static float Q[10000][10000];
int nb_samples = 100000000;
char const* function_name = "sor";
/*
 * Definitions of functions
 */
/*
 * ../src/sor.c:45.6
 */
void initialize(void)
{
   int i;
   int i_1;
   int i_2;
   for (i = 0, i_1 = 0, i_2 = 0; i < 10000; i++, i_1 += 0, i_2++) {
      float* _t1;
      float* _t2;
      double _t3;
      int j;
      int j_1;
      for (_t2 = Q[i],
           _t1 = P[i],
           j = 0,
           j_1 = i_1;
           _t3 = 0.3 + (double)j_1 * 0.5, j < 10000; j++, j_1 += i_2) {
         float _t4;
         _t4 = (float)_t3;
         _t1[j] = _t4;
         _t2[j] = _t4;
      }
   }
}

/*
 * ../src/sor.c:56.6
 */
void initialize_once(void)
{
   initialize();
}

/*
 * ../src/sor.c:62.6
 */
void show(void)
{
   void const* _t1;
   _t1 = P;
   print_submatrix("P", _t1, 10000, 10000, 0, 8, 0, 8);
   print_submatrix("P", _t1, 10000, 10000, 9992, 10000, 9992, 10000);
}

/*
 * ../src/sor.c:72.6
 */
void kernel(void)
{
   union __args_so_main_24* allArgs;
   ocrGuid_t _t1;
   rocrDeclareType(so_main, 1, (unsigned int)1, 1);
   rocrDeclareType(so1, 0, (unsigned int)800, 0);
   rocrInit();
   _t1 = rocrAlloc((void**)&allArgs, 8ul);
   allArgs->data.A = P;
   rocrExecute(1, _t1);
   rocrExit();
}

/*
 * ../src/sor.c:76.5
 */
int check(void)
{
   int i;
   int i_1;
   for (i = 1, i_1 = 0; i < 9999; ) {
      float* _t1;
      float* _t2;
      float* _t3;
      int j;
      int j_1;
      _t2 = Q[i_1];
      _t1 = Q[i];
      i++;
      _t3 = Q[i];
      i_1++;
      for (j_1 = 1, j = 0; j_1 < 9999; ) {
         float* _t4;
         float _t5;
         float _t6;
         int _t7;
         _t4 = _t1 + j_1;
         _t5 = *_t4;
         _t6 = _t1[j];
         _t7 = j_1 + 1;
         *_t4 = (_t5 + _t6 + _t1[_t7] + _t2[j_1] + _t3[j_1]) / 5.0f;
         j++;
         j_1 = _t7;
      }
   }
   return check_matrices("P", "Q", P, Q, 10000, 10000);
}

/*
 * ../src/sor.c:84.8
 */
double flops_per_trial(void)
{
   return (double)(mul_flop + add_flop) * 10000.0 * 10000.0;
}

void so(float (* A)[10000])
{
   union __args_so_main_24* allArgs;
   ocrGuid_t _t1;
   rocrDeclareType(so_main, 1, (unsigned int)1, 1);
   rocrDeclareType(so1, 0, (unsigned int)800, 0);
   rocrInit();
   _t1 = rocrAlloc((void**)&allArgs, 8ul);
   allArgs->data.A = A;
   rocrExecute(1, _t1);
   rocrExit();
}

static ocrGuid_t so1(unsigned int paramc, unsigned long* paramv, unsigned int
   depc, ocrEdtDep_t* depv)
{
   union __args_so1_22 so1_args;
   float (* A_l)[514];
   float (* A)[10000];
   int IT0;
   int IT1;
   ocrGuid_t _t1;
   int _t2;
   int i;
   so1_args = *(union __args_so1_22*)rocrArgs(depv);
   _t1 = rocrAlloc((void**)&A_l, 530448ul);
   IT0 = so1_args.data.IT0;
   IT1 = so1_args.data.IT1;
   A = so1_args.data.A;
   x86_dma_get(A[256 * IT0 + 0] + (512 * IT1 + 0), A_l[0] + 0, (unsigned long)(
      unsigned int)((__mins_32(-512 * IT1 + 10000, 514)) * 4), (long)40000, (
      long)2056, (unsigned long)(unsigned int)(__mins_32(-256 * IT0 + 10000,
      258)), 0);
   _t2 = (__mins_32(-256 * IT0 + 9997, 255));
   x86_dma_wait(0);
   for (i = 0; i <= _t2; i++) {
      int _t3;
      int j;
      for (_t3 = (__mins_32(-512 * IT1 + 9997, 511)), j = 0; j <= _t3; j++) {
         A_l[i + 1][j + 1] = (A_l[i + 1][j + 1] + A_l[i + 1][j] + A_l[i + 1][j +
            2] + A_l[i][j + 1] + A_l[i + 2][j + 1]) / 5.0f;
      }
   }
   x86_dma_put(A_l[1] + 1, A[256 * IT0 + 1] + (512 * IT1 + 1), (unsigned long)(
      unsigned int)((__mins_32(-512 * IT1 + 9998, 512)) * 4), (long)2056, (long
      )40000, (unsigned long)(unsigned int)(__mins_32(-256 * IT0 + 9998, 256)),
       1);
   x86_dma_wait(1);
   ocrDbDestroy(_t1);
   return NULL_GUID;
}

static ocrGuid_t so_main(unsigned int paramc, unsigned long* paramv,
   unsigned int depc, ocrEdtDep_t* depv)
{
   union __args_so_main_24 so_main_args;
   union __args_so1_22* allArgs;
   float (* A)[10000];
   int i;
   int i_1;
   for (so_main_args = *(union __args_so_main_24*)rocrArgs(depv), A =
           so_main_args.data.A, i = 0; i <= 39; i++) {
      int j;
      for (j = 0; j <= 19; j++) {
         ocrGuid_t _t1;
         union __args_so1_22* _t2;
         _t1 = rocrAlloc((void**)&allArgs, 16ul);
         _t2 = allArgs;
         _t2->data.A = A;
         _t2->data.IT0 = i;
         _t2->data.IT1 = j;
         rocrDeclareTask(0, _t1, (unsigned int)(j + 20 * i));
      }
   }
   for (i_1 = 0; i_1 <= 39; i_1++) {
      int _t3;
      int j;
      for (_t3 = (__mins_32(- i_1 + 57, 19)), j = 0; j <= _t3; j++) {
         int _t4;
         int k;
         for (_t4 = (__mins_32(39, i_1 + 1)), k = (__maxs_32(i_1 + j + -18, i_1
                 )); k <= _t4; k++) {
            rocrDeclareDependence(0, (unsigned int)(j + 20 * i_1), 0, (
               unsigned int)(i_1 + j + (-1 * k + 1) + 20 * k));
         }
      }
   }
   rocrScheduleAll();
   return NULL_GUID;
}

