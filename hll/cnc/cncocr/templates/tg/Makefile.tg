# This file is subject to the license agreement located in the file LICENSE
# and cannot be distributed without it. This notice cannot be
# removed or modified.

ifndef XSTACK_ROOT
  $(error Need to specify XSTACK_ROOT!)
endif

# APPS
APPS_ROOT       ?= $(XSTACK_ROOT)/apps
APPS_LIBS_ROOT  ?= $(XSTACK_ROOT)/apps/libs/tg

# OCR_TYPE
OCR_TYPE    ?= tg

# TG
TG_ROOT     ?= $(XSTACK_ROOT)/../intel/ss
TG_INSTALL  ?= $(TG_ROOT)/install

# OCR
XE_TARGET   ?= tg-xe
XE_BUILDER  ?= builder-xe
CE_TARGET   ?= tg-ce
CE_BUILDER  ?= builder-ce

OCR_ROOT         ?= $(XSTACK_ROOT)/ocr
OCR_BUILD_ROOT   ?= $(XSTACK_ROOT)/ocr/build
OCR_INSTALL_ROOT ?= $(XSTACK_ROOT)/ocr/install

ifeq ("$(USE_HAL_LOCKS)", "1")
# Use HAL locks for mutual exclusion
CFLAGS += -DCNC_USE_HAL_LOCKS=1
$(warning Using HAL locks for mutual exclusion)
else
# Use lockable datablocks for mutual exclusion
OCR_CE_CONFIG ?= $(OCR_INSTALL_ROOT)/$(CE_TARGET)/config/ce-multialloc-default-lockable.cfg
OCR_XE_CONFIG ?= $(OCR_INSTALL_ROOT)/$(XE_TARGET)/config/xe-default-lockable.cfg
endif

# APPLICATION
WORKLOAD_SRC          ?= .
WORKLOAD_BUILD_ROOT   ?= ./build
WORKLOAD_INSTALL_ROOT ?= ./install

# XXX - move to top?
# If 0, the workload has no input file
# # If 1+, this is the index in the argument
# # list after which everything is considered an
# # input file. Note that the index STARTS AT 1
WORKLOAD_INPUT_FILE_IDX := 0

# You can specify default arguments here. These
# will be overriden by (in order):
#   - the WORKLOAD_ARGS environment variable
#   - the arguments passed to 'make run'
# To restate, the arguments passed to make run have
# the highest priority and will override both the
# default arguments here and the ones passed through
# an environment variable
#WORKLOAD_ARGS ?=

# Run mode (not fully supported)
# Set to "yes" if running with torque
RUN_TORQUE ?= no
# Set to "yes" if Jenkins is running this job as an automated test
RUN_JENKINS ?= no

MERGED_SRC_FILE := $(WORKLOAD_SRC)/AllSources.$(OCR_TYPE).c

# XXX - not sure why, but the file needs to exist or the rules don't work
$(shell [ -e $(MERGED_SRC_FILE) ] || touch -t 0101010101 $(MERGED_SRC_FILE))


include ${APPS_ROOT}/makefiles/make-pre.inc

# Name of the application to build
TARGET := {{g.name}}

# Space separated list of source files
# (runtime source files and step code files are automatically included later)
APP_SRCS := Main.c {{g.name}}.c

# Additional CFLAGS. By default, it includes
# all OCR required includes and apps/libs/<target>/include
# TG_ARCH is also defined for Fsim
CFLAGS += -I$(WORKLOAD_SRC) -I$(WORKLOAD_SRC)/cncocr_support

# Additional LDFLAGS. By default, it includes
# the required OCR library path and apps/libs/<target/lib
# Note that none of the specific libraries specified in
# REQ_LIBS are included.
LDFLAGS :=

## END of variables coming from user/environment

include cncocr_support/{{g.name}}_defs.mk
CNC_RUNTIME_SRCS := cncocr_support/cncocr.c
CNC_OP_SRCS := $(patsubst %,cncocr_support/{{g.name}}_%_ops.c,step item graph)
CNC_SRCS := $(APP_SRCS) $(CNC_OP_SRCS) $(CNC_STEP_SRCS) $(CNC_RUNTIME_SRCS)

# Space separated list of source files
SRCS := $(MERGED_SRC_FILE)

# Space separated list of directory names in apps/libs/src
# that need to be built. These will be built for ARCH
REQ_LIBS := libc

# Targets:
#   - all:     Build the application.
#   - debug:   Build the debug version of the application
#   - install: Build and install
#   - run:     Run the application
all:	CFLAGS += -O2
all:	TARGETS := all
all:	default

debug:	CFLAGS += -O0
debug:	TARGETS := debug
debug:	default

install: all

default: $(MERGED_SRC_FILE)

$(MERGED_SRC_FILE): $(CNC_SRCS)
	cat $^ > $@

# This rule will be executed prior to execution:
#  - For the FSim target, this happens when the binary is built
#  - For all other targets this happens prior to running the
#    executable
# WORKLOAD_ARGS and WORKLOAD_INPUTS are available
# to you and contain, respectively, the non file
# arguments and the file arguments. They will be
# passed directly to the application unless you
# modify them. You can use the following
# syntax to do so:
# $(eval WORKLOAD_INPUTS := something) or
# $(eval WORKLOAD_INPUTS := $(shell <script>))
# The second syntax will execute <script> and assign
# its output to WORKLOAD_INPUTS
#
# You may also want to assign a value to WORKLOAD_OUTS
# which should contain the list of output files produced
# by the application (to be passed to postrun). This is
# taken-care of for you on FSim but not on any of the
# other platforms.
# 'prerun: ;' is an empty rule (the rule is required)
.PHONY: prerun
prerun: ;

# This rule will be executed after execution
# The variable ${WORKLOAD_OUTS} contains a space separated
# list of output files
# 'postrun: ;' is an empty rule (the rule is required)
.PHONY: postrun
postrun: ;

# Any additional rules required can go here

CONSOLE_OUT_PATH := install/$(OCR_TYPE)/console.out

$(CONSOLE_OUT_PATH):
	@! [ -f $(CONSOLE_OUT_PATH) ] && echo "Must run before printing" && exit 1

# Convenience target for printing the output
.PHONY: print
print: $(CONSOLE_OUT_PATH)
	@echo '>>> Application console output:'
	@cat $(CONSOLE_OUT_PATH)

# Include common part
include ${APPS_ROOT}/makefiles/make-tg.inc

