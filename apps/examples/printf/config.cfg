# ==========================================================================================================
#
# RMD Strawman ("Sunshine++") configuration file for F_SIM
#
# This file demonstrates how to set various parameters for the simulator to exercise with.
#
# Parameters have scoping rules - closer to actual specific agents in the block over-ride global settings.
#
# For example, the "verbose" flag may be over-ridden by later stages of configuration.  The global setting
# is least-binding, while the per-unit setting is most binding.  So if a specific agent setting says "be
# verbose", then it does not matter what other settings indicated.
#
# ==========================================================================================================
#
# Enumerate the list of machines to be used in distributed simulation runs
#

# ==========================================================================================================
# Set up the basic parameters for a top-level single board of Sunshine to simulate - counts of objects and sizes.

[environment]
   WORKLOAD_INSTALL = .
   WORKLOAD_EXEC = .

<<<<<<< HEAD
[BoardGlobal]
   board_space   = 0x1000000000                 # Addresses beyond here are deemed outside of one board
   dram_count    = 1                            # number of DRAM stacks (memory controllers + space) to simulate per board
   dram_size     = 512                          # size in MB for DRAM to simulate per dram_count
   chip_count    = 1                            # number of Sunshine Chips to simulate per board
   board_count   = 1                            # how many boards are in the system?
=======
[TricksGlobal]
   cfg_area_size = 4                            # KB reserved by the ELF loader process
[MachineGlobal]
   rack_count    = 1                            # number of racks in the machine
   cube_count    = 1                            # number of hypercube 8-socket units per rack
   socket_count  = 1                            # number of populated sockets per hypercube
   trace         = 0                            # level and types of trace info to log in output (0 = off)
   verbose       = false                         # default don't speak about spurious things
>>>>>>> e5371db... Minor alloc-related fixes

   dram_ce_fname = $(WORKLOAD_INSTALL)/rmdkrnl       # file to load
   dram_xe_fname = $(WORKLOAD_INSTALL)/printf        # file to load
   dram_bin_fname = $(WORKLOAD_INSTALL)/printf.blob  # file to load


[chip0]
   base_addr     = 0x100000000

# ==========================================================================================================
# Configure the basic parameters of DRAM
#

[DRAMglobal]
   verbose       = false
<<<<<<< HEAD
   sram_addr     = 0x0200000000                # This lives way, way out there in memory space
   sram_size     = 524288                      # Carve out a huge chunk of memory to act as DRAM (in KB)  (524288 = 512M; 1048576 == 1GB)

[dram0]
   base_addr     = 0x200000000
   reg_addr      = 0x2fffffb00                  # for this agent, at what address in the memory map with the PMU/MSR/special registers live

# ==========================================================================================================
# Set up the basic parameters for a top-level chip to simulate - counts of objects and sizes.

[ChipGlobal]
   chip_space    = 0x100000000
   unit_count    = 1
   csm_count     = 1
   csm_size      = 16384
=======
   trace         = 0                            # level and types of trace info to log in output (0 = off)

[dramGlobal]
   verbose       = false
   trace         = 0                            # level and types of trace info to log in output (0 = off)

[nvmGlobal]
   verbose       = false
   trace         = 0                            # level and types of trace info to log in output (0 = off)

[ClusterGlobal]
   sL3_count     = 1                            # how many logical sL3 units exist per cluster
   sL3_size      = 8                            # size in KB for each sL3 unit per cluster
   verbose       = false
   trace         = 0                            # level and types of trace info to log in output (0 = off)
   block_count   = 1
>>>>>>> e5371db... Minor alloc-related fixes

[csm0]
   sram_addr     = 0x20000000                  # for this agent, at what address in the memory map with the PMU/MSR/special registers live
   reg_addr      = 0x3ffffb00                  # for this agent, at what address in the memory map with the PMU/MSR/special registers live

[unit0]
   base_addr     = 0x40000000

[unit1]
   base_addr     = 0x60000000

[unit2]
   base_addr     = 0x80000000

[unit3]
   base_addr     = 0xa0000000

# ==========================================================================================================
# Set up the basic parameters for a unit to simulate - counts of objects and sizes.

[UnitGlobal]
   unit_space    = 0x20000000
   block_count   = 2
   usm_count     = 1
   usm_size      = 8192

[usm0]
   sram_addr     = 0x02000000                  # for this agent, at what address in the memory map with the PMU/MSR/special registers live
   reg_addr      = 0x03fffb00                  # for this agent, at what address in the memory map with the PMU/MSR/special registers live
   verbose       = false
   trace         = 0                            # level and types of trace info to log in output (0 = off)

[block0]
   base_addr     = 0x04000000

[block1]
   base_addr     = 0x06000000

[block2]
   base_addr     = 0x08000000

[block3]
   base_addr     = 0x0a000000

[block4]
   base_addr     = 0x0c000000

[block5]
   base_addr     = 0x0e000000

[block6]
   base_addr     = 0x10000000

[block7]
   base_addr     = 0x12000000

[block8]
   base_addr     = 0x14000000

# ==========================================================================================================
# Set up the basic parameters for a block to simulate - specific XE count, etc.

[BlockGlobal]
   block_space   = 0x02000000                  # how much space does one block consume in the address map in bytes
   agent_space   = 0x00200000                  # how much space does one agent consume in the address map in bytes
   ce_count      = 1                           # ONLY one CE unit in a block will currently work due to QEMU internals
   xe_count      = 8                           # eight XE units in a block - each XE may have its own section defined below
   bsm_count     = 2                           # expect two block shared memory units in a block
   nlni_count    = 1                           # one next-level network-interface module per block is expected
   logfilebase   = $(WORKLOAD_EXEC)/logs/ocr-printf.log          # what is the BASE path+filename to write log files to, default is STDERR
   lsqdepth      = 16                          # How many buffer slots does the common network interface use for in/out queues (originating)
   lsqnetdepth   = 16                          # How many buffer slots does the common network interface use for in/out queues (receiving)
   sl2_count     = 1                           # how many logical sL2 entities per block
   sl2_size      = 2048                        # how many KB is each sL2 entity
   sl1_size      = 64                          # how many KB is each sL1 entity
   num_chains    = 8                           # how many concurrent hardware chains does each chain unit support
   num_dma_buffers = 8                         # how many active concurrent DMA operations can be in progress in the DMA unit
   num_dma_ops     = 16                        # how many DMA operations can be floating around per DMA unit
   num_qma_queues  = 8                         # how many QMA queues will each QMA unit offer
   num_qma_ops     = 16                        # how many QMA operations can be in flight around the QMA queues
   verbose       = false                        # global setting: should we be verbose or not? Can be over-ridden per unit below
   trace         = 0x320000                    # per bit definitions in tg/common/include/tg-trace-values.h
   cache_defined = 1                           # create a cache module for this agent class
   cache_sizeKB    = 32                        # size in KB for cache module
   cache_assoc   = 4                           # associativity for the cache
   cache_lineSZ  = 64                          # line size in bytes for cache module
   cache_policy  = 0x5                         # policy for the cache; at this time, only mode "0x5" (wite-back, write-allocate) is supported!

# ==========================================================================================================
# Configure the basic parameters of each block shared memory unit
#

[BSMglobal]
   verbose       = false
   trace         = 0                            # level and types of trace info to log in output (0 = off)

[CEglobal]
   # Add -d all to qemu_args to get debugging log of QEMU in EVENT_STATS
   qemu_args     = -nographic -kernel $(WORKLOAD_INSTALL)/rmdkrnl # command-line to provide to QEMU when it is launched
#   rmdkrnl_args  =                                              # command-line to provide to RMDKRNL
   rmdkrnl_args  = -mbboot -mbsafepayload                       # command-line to provide to RMDKRNL
#   qemu_args     = -s -kernel ../rmdkrnl/bin/rmdkrnl            # command-line to provide to QEMU when it is launched
#   qemu_args     = -s -S -kernel ../rmdkrnl/bin/rmdkrnl         # command-line to provide to QEMU when it is launched
   sram_size     = 638                          # size in K-bytes for SRAM local to each XE
   cache_defined = 1                           # create a cache module for this agent class
   verbose       = true
   trace         = 0x220000                  # per bit definitions in ss/common/include/tg-trace.h
   enabled       = 1

[XEglobal]
   sram_size     = 64                          # size in K-bytes for SRAM local to each XE
   prf_size      = 512                         # how many physical registers to stick in each XE's PRF
   pmu_size      = 128                         # how many PMU registers exist
   msr_size      = 32                          # how many MSR registers exist
   arf_limit     = 64                          # how many registers to allow an instruction to "see" via encoding space
   cache_defined = 1                           # create a cache module for this agent class
   trace         = 0x6                  # per bit definitions in ss/common/include/tg-trace.h
   verbose       = true
   enabled       = 1

# ==========================================================================================================
# Configure the basic parameters of each next-level network-interface unit
#
# NLNI unlike EAS spec will have only ONE interface - limitation of simulation infrastructure at this time; re-evaluate later

[NLNIglobal]
   verbose       = false
   trace         = 0                            # level and types of trace info to log in output (0 = off)
# ==========================================================================================================
#
#  Default values for energy estimation knobs.
#
# ==========================================================================================================

[DVFS]
   num_bins = 2

[DVFSBin0]
   voltage_V = 0.75
   frequency_divisor = 1
   active_power_mW = 0.7
   static_power_mW = 0.3

[DVFSBin1]
   voltage_V = 0.5
   frequency_divisor = 2
   active_power_mW = 0.3
   static_power_mW = 0.2

[ChipLayout]
   chip_height_mm = 22
   chip_width_mm = 22
   chip_height_num_units = 2
   chip_width_num_units = 2
   unit_height_num_blocks = 4
   unit_width_num_blocks = 2
   data_movement_cost = 0.1   # pJ/bit/mm
   dram_transfer_cost = 5     # pJ/bit

[EnergyGlobal]
   max_freq_MHz  = 1000                         # maximum core frequency

[ipmGlobal]
   ipm_latency   = 75

[dramGlobal]
   dram_latency   = 75

[nvmGlobal]
   nvm_latency   = 300

[sl3Global]
   sl3_latency   = 22

[BlockGlobal]
   static_power_clockgate    = 0.1
   static_power_powergate_soft_mW    = 0.1

[sl2Global]
   sl2_latency   = 8

[NLNIglobal]
   static_power_clockgate    = 0.1
   static_power_powergate_soft_mW    = 0.1
   intrablock_cost    = 1
   intraunit_cost     = 3
   block_to_unit_cost = 9
   intrachip_cost     = 27
   unit_to_chip_cost  = 81
   intraboard_cost    = 243
   chip_to_board_cost = 729
   interboard_cost    = 2187

[environment]
    TG_INSTALL = /home/bseshasa/xstg/tg/tg/install
