This directory provides an implementation of reductions using labeled GUIDs.

Labeled GUIDs are currently experimental so it is necessary to include

#define ENABLE_EXTENSION_LABELING
#include "extensions/ocr-labeling.h"

it is also necessary to change the GUID factory to "LABELED"
this is accomplished by adding the line

CONFIG_FLAGS=--guid LABELED

in Makefile.x86 and Makefile.x86-mpi

driver.c : a sample driver which exercises double precision addition


Any driver code for the library must:
   create and initialize a reductionPrivate datablock (defined in reduction1.h)

However before calling reductionLaunch the user must
  1. create a reductionPrivate datablock for each participating rank
  2. create a clone to receive the result of the reduction
  3. initialize some of the values in the reductionPrivate datablock
      nrank: number of participating ranks
      myrank: my number
      ndata: number of elements to be reduced
      new: set to TRUE for the first call
      reductionOperator: choose which reduction to do (choices in reduction1.h)
      rangeGUID: a set of at least nrank-1 labeled STICKY event GUIDs
      returnEVT: a ONCE event (presumably labeled) that rank 0 will use
         to return the reduced data to the clones
   4. make the clone depend on the returnEVT

After the first call to reductionLaunch, subsequent reductions only require changing the
returnEVT (which should alternate between 2 labeled ONCE guids)


Now the reduction library can be called by the nrank compute EDTs using one call:


Compute the local contribution to be reduced in a datablock
**RELEASE THE DATA BLOCK***
to make your changes visible and then call

void reductionLaunch(reductionPrivate_t * rpPTR, ocrGuid_t reductionPrivateGUID, ocrGuid_t mydataGUID);

rpPTR is the pointer to my reductionPrivate datablock
reductionPrivateGUID is the guid of my reductionPrivate block
mydataGUID is the guid of the datablock containing my contribution to the global reduction

reductionLaunch returns after launching the global sum algorithm.  The calling Edt should terminate soon after
and wait for the clone to wake up.



The library implements a reduction tree invoking the reduction operator at each stage.  This amounts to a global barrier since every node must
contribute to the global reduction before Node zero returns the result by satisfying the event with a separate datablock

Reductions can be run as often as desired.

The available operations are defined in the enum type reductionOperator_t in reduction1.h

To add other operations requires three changes:

add the new key word to the enum type reductionOperator_t (in reduction.h);

add the new key word in reductionsizeof (in reductionLib.c)

add the actual operation to reductionOperation (in reductionLib.c)

recompile


