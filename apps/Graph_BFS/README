@author Austin Gibbons
@date September 2011

This is a series of Breadth First Search implementations:
	(0) Serial version
	(1) HTA model based off of Austin's previous work
	(2) Cache friendly based off of Pradeep's group's implementation
	(3) AFL / Scratchpad version of HTA

(1) Was made very quickly from scratch. It is certainly not polished and was more "pounded out" then "intelligently designed"
(2) Is a translation of a much more tuned version from an applications group within Intel. It makes some of the same optimizations
	but does not interface with the architecture as the original does, or do smart work partitioning
(3) This was also made rather quickly. It was a "proof-of-concept" implementation of the importance of matching your implementation to your
	graph size and available hardware. It assumes that the edgelists can fit into the local memories, and that this is the limiting capacity

From any directory:

compile:
	make clean
	make

run:
	./[executable] [file] [numthreads] [exlore_depth - only for HTA versions]

example:
	cd AFL_HTA
	make clean
	make
	./parallel_bfs ../Newput/default.txt 8

IF YOU ARE TASKED WITH MAKING CHANGES:
	I made the HTA version without really knowing what it would be used for
	As such, I tried to make it "flexible" with all these node pointers
	such that the internals of a node could be changed easily.
	It also supports speculation, which is what necessitates the huge memory
	overhead. For more information, find the write-ups I sent to Justin Teller.
	This HTA version is really  much uglier if all you want are integer vertices.
	The cache-friendly/pradeep version has just integer edgelists and not
	all the pointer nonsense, so it is faster and a little nicer to look at.

	I don't know what your specific goals are, but I recommend using my code as a reference 
	if need be and creating your own version from scratch. It is just BFS, not a terribly 
	large code or confusing algorithm.
