#include "ocr.h"
#include "ocr-std.h"

#include <math.h>
#define NDEBUG 1 //Remove c assertions.
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#include "io_lammps.h"

/*
    This program does a molecular dynamics simulation using Lennard Jones
    Potentials. It is parallelized using a link cell approach. Each cell
    owns a set of spacial coordinates and any atom within is owned by the cell.

    At a high level, the problem is split into iterations. Each iteration
    contains a half momentum/position step, followed by a force step, followed
    by a half momentum step. These are linked using output (control)
    dependencies.

    During each step, each cell will concurrently compute for the atoms it owns.

    Note: the code is written in such a way as to be portable on both shared and
          distributed versions of OCR (i.e. it does not use global state.)
          However, it has not yet been tested on on distributed OCR.

          The current version of OCR does not enforce the RO/ITW/EW properties
          for dependencies. This means there could be potential bugs lurking
          below once those have begun to be enforced.
*/

//TODO: print assertion status
//TODO: print optimization status
//TODO: document overall implementation. E.g. buffers.
//TODO: Optimization: Noncontiguous memory?
//TODO: Optimization: don't bother checking atom interactions with remote boxes
//      if an atom isn't within cutoff distance of another box.

/**********************/

///*** CONFIGURATION OPTIONS ***///

#define CELL_SIZE 500l //cell buffer size (how many atoms will fit).

#define OPT_HALF_NEIGH 1    //enable half neighbor optimizations. Symmetry!

// This option will not work in distributed OCR!
#define _OCR_IS_BROKEN 1    // enables workarounds for broken parts of OCR. E.g. exclusive writes.

#define _DEBUG 1            //Enable debugging.
#define _DEBUG_STDOUT 1     //Enable writing to standard out.

///FIXME: Note this option will break in distributed OCR because we use a single file handle in global space!
///FIXME: Global access to simulation space is no longer supported -- so this option is broken even in shared memory OCR.
//#define _DEBUG_FILE_WRITE 1 //Write output to a file.

/**********************/

// ............................ //
// ............................ //
// ... Begin implementation ... //
// ............................ //
// ............................ //

#define POT_SHIFT 1.0
/// Text taken from CoMD:
/// This is set to 1.0 by default, and shifts the values of the cohesive
/// energy given by the Lennard-Jones potential so it is zero at the
/// cutoff radius.  This setting improves energy conservation
/// step-to-step as it reduces the noise generated by atoms crossing the
/// cutoff threshold. However, it does not affect the long-term energy
/// conservation of the code.

// Avoid unused errors in cases where we don't care because sometimes we want
// to be pedantic and other times we really don't use legit unused variables.
#define _UNUSED(expr) do { (void)(expr); } while (0)

// Convert id into coordinates.
#define GET_X(id, dims) (id%dims)
#define GET_Y(id, dims) (id/dims%dims)
#define GET_Z(id, dims) (id/(dims*dims))

// Useful only in debug builds.
#if _DEBUG == 1 && _DEBUG_FILE_WRITE == 1 ///FIXME: See note above about this option!
#error OCR MD no longer supports referencing global simulation space data.
FILE* _debugHandle;             // out file handle.
#endif

#if _OCR_IS_BROKEN == 1
#include <pthread.h>
pthread_mutex_t* FOO_MUTEX; // used in place of exclusive writes.
#endif

/*
    Some bookkeeping and cellType information is duplicated.
    This is in order to minimize the number of DBs we use as dependencies to EDTs.
*/
struct bookkeeping
{
    double timestep;                   // time step interval.
    s64 num_timesteps;                 // count of iterations before stopping.
    s64 initial_iteration;             // iteration to start on.
    s64 iteration;                     // current iteration.
    s64 number_atoms;                  // Count of atoms in problem.
    s64 cell_count;                    // count of cells.
    s64 cell_per_dims;                 // count of cells per dimensions.
    s64 x_period, y_period, z_period;  //periodic boundary condition bools.

    #if _DEBUG == 1
    #if _DEBUG_FILE_WRITE == 1 || _DEBUG_STDOUT == 1
    s64 write_freq;           //frequency to display output.
    s64 write_count;          // write count interval. Initiates when reaching zero.
    #endif
    #endif
};

// Cell information.
struct cellType
{
    s64 id;
    s64 x_coor, y_coor, z_coor;              //coordinates.
    double x_lo, y_lo, z_lo;                 //low boundaries.
    double x_hi, y_hi, z_hi;                 //high boundaries.
    s64 x_period, y_period, z_period;        //periodic boundary condition bools.
    double timestep, sigma, epsilon, cutoff; // problem parameters
    s64 cell_count;                          // count of total cells.
    s64 cell_per_dims;                       // count of cells per dimensions.
    s64 count;                               // count of atoms in cell.
    struct atomType atoms[];                 // FIXME: DOCUMENT THIS C FEATURE.
};

// List of GUIDs.
struct dbList
{
    s64 count;      //number of DBs in the list.
    ocrGuid_t db[]; // FIXME: DOCUMENT THIS C FEATURE.
};

// GUIDs for each task template.
struct templateType
{
    ocrGuid_t spawnMomPos;
    ocrGuid_t calcMomPos;
    ocrGuid_t spawnGather;
    ocrGuid_t gather;
    ocrGuid_t scatter;
    ocrGuid_t spawnFor;
    ocrGuid_t calcFor;
    ocrGuid_t spawnMom;
    ocrGuid_t calcMom;
    ocrGuid_t timestep;
    ocrGuid_t debug;
};

/*
    Places a copy of an atom in the specified move buffer.

    depv[0] : Copy of atom to place in the move buffer.
    depv[1] : Moved buffer to place atom in.
*/
ocrGuid_t FUNC_scatter(u32 paramc, u64* paramv, u32 depc, ocrEdtDep_t depv[])
{
    _UNUSED(paramc); _UNUSED(paramv); _UNUSED(depc);
    ///PRINTF("Starting FUNC_scatter\n");

    // Grab data.
    struct atomType* atom = depv[0].ptr; //atom to move in.
    struct cellType* move = depv[1].ptr; //move buffer.

    #if _OCR_IS_BROKEN == 1
    /**************************************************************************/
    // Work around since exclusive writes aren't implemented. -_- ...
    pthread_mutex_lock(&FOO_MUTEX[move->id]);
    /**************************************************************************/
    #endif

    // Copy atom into the move buffer.
    move->atoms[move->count] = *atom;
    move->count++;

    if(move->count>CELL_SIZE)
    {
        printf("Error, more than CELL_SIZE (%ld) atoms in a move buffer!\n", CELL_SIZE);
        ocrShutdown();
        return NULL_GUID;
    }

    // Destroy the DB used to store the atom.
    ocrDbDestroy(depv[0].guid);

    #if _OCR_IS_BROKEN == 1
    /**************************************************************************/
    pthread_mutex_unlock(&FOO_MUTEX[move->id]);
    /**************************************************************************/
    #endif

    return NULL_GUID;
}

/*
    Copies the move buffer over to the main cell.

    depv[0] : Cell that contains atoms.
    depv[1] : Move buffer that contains atoms.
*/
ocrGuid_t FUNC_gather(u32 paramc, u64* paramv, u32 depc, ocrEdtDep_t depv[])
{
    _UNUSED(paramc); _UNUSED(paramv); _UNUSED(depc);
    ///PRINTF("Starting FUNC_gather\n");

    // Grab data.
    struct cellType* cell = depv[0].ptr; // cell of atoms.
    struct cellType* move = depv[1].ptr; // atoms to move into cell.

    //Sanity, make sure this is a valid id.
    assert(cell->id<cell->cell_count);
    assert(move->id<cell->cell_count);

    // Move any atoms that shifted cells.
    for (; move->count; --move->count)
    {
        cell->atoms[cell->count] = move->atoms[move->count-1];
        cell->count++;

        if(cell->count>CELL_SIZE)
        {
            printf("Error, more than CELL_SIZE (%ld) atoms in a cell!\n", CELL_SIZE);
            ocrShutdown();
            return NULL_GUID;
        }
    }

    return NULL_GUID;
}

/*
    Calculates the half momentum and position for a given cell. Additionally
    schedules movement tasks for atoms that change cells.

    depv[0] : Cell that contains atoms.
    depv[1] : List of move buffers. If an atom moves outside of our cell we
              schedule it to be placed in a move buffer.
*/
ocrGuid_t FUNC_calcMomPos(u32 paramc, u64* paramv, u32 depc, ocrEdtDep_t depv[])
{
    _UNUSED(paramc); _UNUSED(paramv); _UNUSED(depc);
    ///PRINTF("Starting FUNC_calcMomPos\n");

    // Grab data.
    struct cellType* cell         = depv[0].ptr; // cell of atoms.
    struct dbList* move_list      = depv[1].ptr; // list of all move buffers.
    struct templateType* TEMPLATE = depv[2].ptr; // list of template GUIDs.

    //Sanity, make sure this is a valid id.
    assert(cell->id<cell->cell_count);

    // Iterate over each atom in this cell, computing momentum.
    for (s64 i=0; i<cell->count; i++)
    {
        // Fancy momentum calculation.
        cell->atoms[i].mom_x += cell->timestep * 0.5 * cell->atoms[i].for_x;
        cell->atoms[i].mom_y += cell->timestep * 0.5 * cell->atoms[i].for_y;
        cell->atoms[i].mom_z += cell->timestep * 0.5 * cell->atoms[i].for_z;

        // Fancy position calculation.
        cell->atoms[i].pos_x += cell->atoms[i].mom_x/cell->atoms[i].mass * cell->timestep;
        cell->atoms[i].pos_y += cell->atoms[i].mom_y/cell->atoms[i].mass * cell->timestep;
        cell->atoms[i].pos_z += cell->atoms[i].mom_z/cell->atoms[i].mass * cell->timestep;

        // Check periodic boundaries for x.
        if(cell->x_period && cell->atoms[i].pos_x <= cell->x_lo)
            cell->atoms[i].pos_x += (cell->x_hi - cell->x_lo);
        else if(cell->x_period && cell->atoms[i].pos_x >= cell->x_hi)
            cell->atoms[i].pos_x -= (cell->x_hi - cell->x_lo);

        // Check periodic boundaries for y.
        if(cell->y_period && cell->atoms[i].pos_y <= cell->y_lo)
            cell->atoms[i].pos_y += (cell->y_hi - cell->y_lo);
        else if(cell->y_period && cell->atoms[i].pos_y >= cell->y_hi)
            cell->atoms[i].pos_y -= (cell->y_hi - cell->y_lo);

        // Check periodic boundaries for z.
        if(cell->z_period && cell->atoms[i].pos_z <= cell->z_lo)
            cell->atoms[i].pos_z += (cell->z_hi - cell->z_lo);
        else if(cell->z_period && cell->atoms[i].pos_z >= cell->z_hi)
            cell->atoms[i].pos_z -= (cell->z_hi - cell->z_lo);

        // zero out forces.
        cell->atoms[i].for_x = cell->atoms[i].for_y = cell->atoms[i].for_z = 0.0;

    }

    /// Rebinning step.
    {
    // Check atoms to see if they should be moved into a different box.
    for(s64 i=0; i<cell->count; ++i)
    {
        // Make sure we meet the boundary conditions.
        assert(cell->atoms[i].pos_x<=cell->x_hi);
        assert(cell->atoms[i].pos_y<=cell->y_hi);
        assert(cell->atoms[i].pos_z<=cell->z_hi);
        assert(cell->atoms[i].pos_x>=cell->x_lo);
        assert(cell->atoms[i].pos_y>=cell->y_lo);
        assert(cell->atoms[i].pos_z>=cell->z_lo);

        // Find new cell for atom.
        s64 x = (cell->atoms[i].pos_x-(cell->x_lo))/((cell->x_hi - cell->x_lo)/cell->cell_per_dims);
        s64 y = (cell->atoms[i].pos_y-(cell->y_lo))/((cell->y_hi - cell->y_lo)/cell->cell_per_dims);
        s64 z = (cell->atoms[i].pos_z-(cell->z_lo))/((cell->z_hi - cell->z_lo)/cell->cell_per_dims);

        // Capture edge cases that are perfectly on the boundary of the problem.
        if(x==cell->cell_per_dims) x--;
        if(y==cell->cell_per_dims) y--;
        if(z==cell->cell_per_dims) z--;

        // Sanity, make sure we are in a valid cell.
        assert(x<cell->cell_per_dims);
        assert(y<cell->cell_per_dims);
        assert(z<cell->cell_per_dims);

        // Compute new cell id.
        s64 newCellID = x+y*cell->cell_per_dims+z*cell->cell_per_dims*cell->cell_per_dims;
        ocrGuid_t EDT_scatter;

        // If ID's changed then we should be in a different cell now.
        if(newCellID != cell->id)
        {
            // schedule movement task.
            ocrEdtCreate(&EDT_scatter, TEMPLATE->scatter, EDT_PARAM_DEF,
                         /*paramv=*/NULL, EDT_PARAM_DEF, /*depv=*/NULL,
                         /*properties=*/ NULL_GUID, NULL_GUID,
                         /*outEvent=*/NULL);

            // create silly DB to pass the atom to new cell.
            ocrGuid_t DB_atomToMove;
            struct atomType* atomToMove;
            ocrDbCreate(&DB_atomToMove,(void **) &atomToMove,
                        sizeof(struct atomType), DB_PROP_NONE, NULL_GUID, NO_ALLOC);
            *atomToMove = cell->atoms[i];

            // The new task shouldn't fire until this one and any others using these DBs finishes.
            ocrAddDependence(DB_atomToMove,            EDT_scatter, 0, DB_MODE_RO); // DB of the data.
            ocrAddDependence(move_list->db[newCellID], EDT_scatter, 1, DB_MODE_EW);

            // Remove atom from this cell (since a copy was scheduled to be inserted in another cell).
            cell->atoms[i--] = cell->atoms[--cell->count];
        }
    }
    }

    return NULL_GUID;
}

/*
    Calculates the force for a given cell. Note that specific neighbors are
    placed into specific slots and that the slot determines spatially where a
    neighbor is located.

    depv[13] : Our cell for purposes of force computation.
    depv[0] - depv[12] : Neighbor cells.
    depv[14] - depv[26] : Neighbor cells.
*/
ocrGuid_t FUNC_calcFor(u32 paramc, u64* paramv, u32 depc, ocrEdtDep_t depv[])
{
    _UNUSED(paramc); _UNUSED(paramv); _UNUSED(depc); _UNUSED(depv);
    ///PRINTF("Starting FUNC_calcFor\n");

    // Note: 13 is 'our' cell. This allows us to handle symmetry relatively
    // uniformly without much code duplication.
    struct cellType* cell = depv[13].ptr; // Cell of atoms.

    //Sanity, make sure this is a valid id.
    assert(cell->id<cell->cell_count);

    /* Begin computing forces. */
    s64 x_off, y_off, z_off; //offsets used to determine spatial relationship of neighbor cells.
    s64 slot = 0; //our slot.
    ///Warning: The ordering on these dependencies is important. The offset
    ///          logic here needs to be duplicated in the SpawnFor() EDTs
    ///          as it is used determine spatially where a neighbor is for
    ///          periodic conditions.
    for (x_off=-1; x_off<=1; ++x_off) {
    for (y_off=-1; y_off<=1; ++y_off) {
    for (z_off=-1; z_off<=1; ++z_off)
    {
        // NULL signifies the end of valid neighbors (non-periodic).
        if (depv[slot].guid == NULL_GUID) {
            slot++;
            continue; //skip.
        }

        // Grab another cell.
        struct cellType* rCell = depv[slot].ptr;

        //Sanity, make sure this is a valid id.
        assert(rCell->id<rCell->cell_count);

        // Iterate over all atoms within the specified cell which we are
        // denoting a remote or 'r' cell.
        for (s64 i=0; i<rCell->count; i++) {

            // Determine whether the 'r' cell is actually 'our' cell. If so,
            // we need to avoid computing forces twice so change start location.
            s64 start  = (cell->id == rCell->id ? i+1 : 0);

            // Iterate over 'our' cell.
            for(s64 j=start; j<cell->count; j++)
            {
                // Sanity -- Make sure we aren't computing forces of an atom with itself.
                assert(rCell->atoms[i].id != cell->atoms[j].id);

                // Record position of remote atom.
                double pos_x = rCell->atoms[i].pos_x;
                double pos_y = rCell->atoms[i].pos_y;
                double pos_z = rCell->atoms[i].pos_z;

                // Check periodicity and adjust if at boundaries.
                {
                    if(rCell->x_period == 1) //periodic?
                    {
                        if((cell->x_coor+x_off) < 0)
                            pos_x -= (rCell->x_hi-rCell->x_lo); //left boundary.
                        else if((cell->x_coor+x_off) >= cell->cell_per_dims)
                            pos_x += (rCell->x_hi-rCell->x_lo); //right boundary.
                    }

                    if(rCell->y_period == 1) //periodic?
                    {
                        if((cell->y_coor+y_off) < 0)
                            pos_y -= (rCell->y_hi-rCell->y_lo); //left boundary.
                        else if((cell->y_coor+y_off) >= cell->cell_per_dims)
                            pos_y += (rCell->y_hi-rCell->y_lo); //right boundary.
                    }

                    if(rCell->z_period == 1) //periodic?
                    {
                        if((cell->z_coor+z_off) < 0)
                            pos_z -= (rCell->z_hi-rCell->z_lo); //left boundary.
                        else if((cell->z_coor+z_off) >= cell->cell_per_dims)
                            pos_z += (rCell->z_hi-rCell->z_lo); //right boundary.
                    }
                }

                // Compute distance^2 of the particles.
                double dx = cell->atoms[j].pos_x - pos_x;
                double dy = cell->atoms[j].pos_y - pos_y;
                double dz = cell->atoms[j].pos_z - pos_z;
                double r2 = dx*dx + dy*dy + dz*dz;

                // Check cutoff -- if above particles don't have near field interactions.
                if (r2 > cell->cutoff*cell->cutoff)
                    continue;

                // Compute the forces.
                r2 = 1.0/r2;
                double s6 = cell->sigma*cell->sigma*cell->sigma*cell->sigma*cell->sigma*cell->sigma;

                //Shift the energy to 0.0.
                double rCut6 = s6/(cell->cutoff*cell->cutoff*cell->cutoff*cell->cutoff*cell->cutoff*cell->cutoff);
                double eShift = POT_SHIFT * rCut6 * (rCut6 - 1.0);

                double r6 = s6*(r2*r2*r2);
                double fr = -4.0*cell->epsilon*r6*r2*(12.0*r6 - 6.0);
                double pot = 0.5*(r6*(r6-1.0)-eShift);
                double dx_fr = dx*fr;
                double dy_fr = dy*fr;
                double dz_fr = dz*fr;

                #if _OCR_IS_BROKEN == 1 && OPT_HALF_NEIGH == 1
                /**************************************************************************/
                // Work around since exclusive writes aren't implemented. -_- ...
                pthread_mutex_lock(&FOO_MUTEX[cell->id]);
                /**************************************************************************/
                #endif

                // Normalize to account for the additional sigma we are using above.
                cell->atoms[j].potential += pot;
                cell->atoms[j].for_x -= dx_fr;
                cell->atoms[j].for_y -= dy_fr;
                cell->atoms[j].for_z -= dz_fr;

                #if _OCR_IS_BROKEN == 1 && OPT_HALF_NEIGH == 1
                /**************************************************************************/
                pthread_mutex_unlock(&FOO_MUTEX[cell->id]);
                /**************************************************************************/
                #endif

                //If using half neighbor opt -- always take advantage of symmetry.
                #if OPT_HALF_NEIGH != 1 /// NOT
                if (cell->id == rCell->id) // Same cell -- so take advantage of symmetry.
                #endif
                {
                    #if _OCR_IS_BROKEN == 1 && OPT_HALF_NEIGH == 1
                    /**************************************************************************/
                    // Work around since exclusive writes aren't implemented. -_- ...
                    pthread_mutex_lock(&FOO_MUTEX[rCell->id]);
                    /**************************************************************************/
                    #endif

                    //Accumulate energies.
                    rCell->atoms[i].potential += pot;

                    // Symmetry is essential.
                    // Accumulate forces the other particle here instead of recomputing forces later.
                    rCell->atoms[i].for_x += dx_fr;
                    rCell->atoms[i].for_y += dy_fr;
                    rCell->atoms[i].for_z += dz_fr;

                    #if _OCR_IS_BROKEN == 1 && OPT_HALF_NEIGH == 1
                    /**************************************************************************/
                    pthread_mutex_unlock(&FOO_MUTEX[rCell->id]);
                    /**************************************************************************/
                    #endif
                }
            }
        }

        // Next slot...
        slot++;
    }}}

    return NULL_GUID;
}

/*
    Calculates the half momentum for a given cell.

    depv[0] : Cell that contains atoms.
*/
ocrGuid_t FUNC_calcMom(u32 paramc, u64* paramv, u32 depc, ocrEdtDep_t depv[])
{
    _UNUSED(paramc); _UNUSED(paramv); _UNUSED(depc);
    ///PRINTF("Starting FUNC_calcMom\n");

    // Get data.
    struct cellType* cell = depv[0].ptr; // cell of atoms.

    //Sanity, make sure this is a valid id.
    assert(cell->id<cell->cell_count);

    // Iterate over each atom in this cell computing momentum.
    for (s64 i=0; i<cell->count; i++)
    {
        // Fancy momentum calculation.
        cell->atoms[i].mom_x += cell->timestep * 0.5 * cell->atoms[i].for_x;
        cell->atoms[i].mom_y += cell->timestep * 0.5 * cell->atoms[i].for_y;
        cell->atoms[i].mom_z += cell->timestep * 0.5 * cell->atoms[i].for_z;

        // Energy computations.
        cell->atoms[i].kinetic = 0.5 * cell->atoms[i].mass * (cell->atoms[i].mom_x/cell->atoms[i].mass)*(cell->atoms[i].mom_x/cell->atoms[i].mass);
        cell->atoms[i].kinetic += 0.5 * cell->atoms[i].mass * (cell->atoms[i].mom_y/cell->atoms[i].mass)*(cell->atoms[i].mom_y/cell->atoms[i].mass);
        cell->atoms[i].kinetic += 0.5 * cell->atoms[i].mass * (cell->atoms[i].mom_z/cell->atoms[i].mass)*(cell->atoms[i].mom_z/cell->atoms[i].mass);
    }

    return NULL_GUID;
}

/*
    Spawns the momentumPosition calculation EDTs for a timestep.

    depv[0] : finishEDT dependency (for control dependencies).
    depv[1] : List of cells.
    depv[2] : List of move buffers.
*/
ocrGuid_t FUNC_spawnMomPos(u32 paramc, u64* paramv, u32 depc, ocrEdtDep_t depv[])
{
    _UNUSED(paramc); _UNUSED(paramv); _UNUSED(depc);
    ///PRINTF("Starting FUNC_spawnMomPos\n");

    // Grab data.
    struct dbList* cell_list      = depv[1].ptr;  // List of cells.
    ocrGuid_t DB_move_list        = depv[2].guid; // Guid of the move DB list.
    struct templateType* TEMPLATE = depv[3].ptr;  // list of template GUIDs.
    ocrGuid_t DB_templates        = depv[3].guid;

    //Create tasks for each cell.
    for (s64 i=0; i<cell_list->count; i++)
    {
        ocrGuid_t EDT_calcStep;
        ocrEdtCreate(&EDT_calcStep, TEMPLATE->calcMomPos, EDT_PARAM_DEF,
                     /*paramv=*/NULL, EDT_PARAM_DEF, /*depv=*/NULL,
                     /*properties=*/ NULL_GUID, NULL_GUID,
                     /*outEvent=*/NULL);

        //Pass a cell to each calc step.
        ocrAddDependence(cell_list->db[i], EDT_calcStep, 0, DB_MODE_EW); //EW or ITW -- either should be fine for this step.
        //Pass list of move buffers to each calc step -- so they can schedule atom movement tasks.
        ocrAddDependence(DB_move_list,     EDT_calcStep, 1, DB_MODE_RO);
        //Pass list of templates -- since this step will spawn some EDTs.
        ocrAddDependence(DB_templates,     EDT_calcStep, 2, DB_MODE_RO);
    }

    return NULL_GUID;
}

/*
    Spawns gather EDTs for each cell which copy move buffers over to the corresponding cell.

    depv[0] : finishEDT dependency (for control dependencies).
    depv[1] : List of cells.
    depv[2] : List of move buffers.
*/
ocrGuid_t FUNC_spawnGather(u32 paramc, u64* paramv, u32 depc, ocrEdtDep_t depv[])
{
    _UNUSED(paramc); _UNUSED(paramv); _UNUSED(depc);
    ///PRINTF("Starting FUNC_spawnGather\n");

    // Grab data.
    struct dbList* cell_list      = depv[1].ptr; // cell list.
    struct dbList* move_list      = depv[2].ptr; // move list.
    struct templateType* TEMPLATE = depv[3].ptr; // list of template GUIDs.

    // Create tasks for each cell.
    for (s64 i=0; i<cell_list->count; i++)
    {
        ocrGuid_t EDT_calcStep;
        ocrEdtCreate(&EDT_calcStep, TEMPLATE->gather, EDT_PARAM_DEF,
                     /*paramv=*/NULL, EDT_PARAM_DEF, /*depv=*/NULL,
                     /*properties=*/ NULL_GUID, NULL_GUID,
                     /*outEvent=*/NULL);

        // Satisfy dependencies with a cell and a move buffer.
        ocrAddDependence(cell_list->db[i], EDT_calcStep, 0, DB_MODE_EW); //EW or ITW -- either should be fine for this step.
        ocrAddDependence(move_list->db[i], EDT_calcStep, 1, DB_MODE_EW); //EW or ITW -- either should be fine for this step.
    }

    return NULL_GUID;
}

/*
    Spawns calc force EDT for each cell. Note that specific neighbors are
    placed into specific slots and that the slot determines spatially where a
    neighbor is located.

    depv[0] : finishEDT dependency (for control dependencies).
    depv[1] : List of cells.
*/
ocrGuid_t FUNC_spawnFor(u32 paramc, u64* paramv, u32 depc, ocrEdtDep_t depv[])
{
    _UNUSED(paramc); _UNUSED(paramv); _UNUSED(depc);
    ///PRINTF("Starting FUNC_spawnForceStep\n");

    // Grab data.
    struct dbList* cell_list      = depv[1].ptr;
    struct templateType* TEMPLATE = depv[2].ptr; // list of template GUIDs.
    struct bookkeeping* book      = depv[3].ptr; // for periodicity information.

    // Create tasks for each cell.
    for (s64 i=0; i<cell_list->count; i++)
    {
        // Get coordinates of cell (we can't refer to a non-acquired DB's memory).
        s64 x_coor = GET_X(i, book->cell_per_dims);
        s64 y_coor = GET_Y(i, book->cell_per_dims);
        s64 z_coor = GET_Z(i, book->cell_per_dims);

        // Create task for a given cell.
        ocrGuid_t EDT_calcStep;
        ocrEdtCreate(&EDT_calcStep, TEMPLATE->calcFor, EDT_PARAM_DEF,
                     /*paramv=*/NULL, EDT_PARAM_DEF, /*depv=*/NULL,
                     /*properties=*/ NULL_GUID, NULL_GUID,
                     /*outEvent=*/NULL);

        // Add the neighbor dependencies for each cell.
        s64 x_off, y_off, z_off; //offsets for neighbor coordinates.
        s64 slot = 0;
        ///Warning: The ordering on these dependencies is important. The offset
        ///          logic here needs to be duplicated in the calcFor() EDTs
        ///          as it is used determine spatially where a neighbor is for
        ///          periodic conditions.
        for (x_off=-1; x_off<=1; ++x_off) {
        for (y_off=-1; y_off<=1; ++y_off) {
        for (z_off=-1; z_off<=1; ++z_off)
        {
            // Because inline macros are fun?
            // Wraps boundaries of out of bounds neighbor indexes to the correct ones.
            #define _BNDS(a) ((a<0) ? (book->cell_per_dims-1) : (a>=book->cell_per_dims?0:a))
            //find your neighbor -- corrects for periodic boundaries.
            s64 neiCellID = _BNDS(x_coor+x_off) + _BNDS(y_coor+y_off)*book->cell_per_dims +
                            _BNDS(z_coor+z_off)*book->cell_per_dims*book->cell_per_dims;

            //Check if something is a neighbor for non-periodics and continue if not.
            if ((book->x_period==0 && (x_coor+x_off<0 || x_coor+x_off>=book->cell_per_dims)) ||
                (book->y_period==0 && (y_coor+y_off<0 || y_coor+y_off>=book->cell_per_dims)) ||
                (book->z_period==0 && (z_coor+z_off<0 || z_coor+z_off>=book->cell_per_dims)))
            {
                // Non-periodic, add false dependency because why not?
                ocrAddDependence(NULL_GUID, EDT_calcStep, slot, DB_MODE_ITW);
            }
            #if OPT_HALF_NEIGH == 1
            else if(i>neiCellID) // only actually add neighbors with IDs higher than us.
            {
                ocrAddDependence(NULL_GUID, EDT_calcStep, slot, DB_MODE_ITW);
            }
            else // Periodic case.
            {
                //Add neighbor dependency (or ourself).
                ocrAddDependence(cell_list->db[neiCellID], EDT_calcStep, slot, DB_MODE_EW); //EW required since multiple tasks can modify a cells forces.
            }
            #else ///Note: this case doesn't use exclusive writes since a single task only modifies the cell it 'owns' in this case. ITW is needed because we want to allow more parallelism.
            else // Periodic case.
            {
                //Add neighbor dependency (or ourself).
                ocrAddDependence(cell_list->db[neiCellID], EDT_calcStep, slot, DB_MODE_ITW);
            }
            #endif
            slot++; //next slot.
        }}}
    }

    return NULL_GUID;
}

/*
    Spawns calc half momentum EDT for each cell.

    depv[0] : finishEDT dependency (for control dependencies).
    depv[1] : List of cells.
*/
ocrGuid_t FUNC_spawnMom(u32 paramc, u64* paramv, u32 depc, ocrEdtDep_t depv[])
{
    _UNUSED(paramc); _UNUSED(paramv); _UNUSED(depc);
    ///PRINTF("Starting FUNC_spawnMom\n\n");

    // Grab data.
    struct dbList* cell_list      = depv[1].ptr; // list of cells.
    struct templateType* TEMPLATE = depv[2].ptr; // list of template GUIDs.

    // Create tasks for each cell.
    for (s64 i=0; i<cell_list->count; i++)
    {
        // Create task.
        ocrGuid_t EDT_calcStep;
        ocrEdtCreate(&EDT_calcStep, TEMPLATE->calcMom, EDT_PARAM_DEF,
                     /*paramv=*/NULL, EDT_PARAM_DEF, /*depv=*/NULL,
                     /*properties=*/ NULL_GUID, NULL_GUID,
                     /*outEvent=*/NULL);

        // Add cell as a dependency.
        ocrAddDependence(cell_list->db[i], EDT_calcStep, 0, DB_MODE_EW); //EW or ITW -- either should be fine for this step.
    }

    return NULL_GUID;
}

/*
    Writes the velocity, position, and forces of each atom to a file for the
    given iteration.

    depv[0] : finishEDT dependency (for control dependencies).
    depv[1] : the current iteration (time).
    depv[i*2+2] : a cell.
    depv[i*2+3] : a move buffer.
*/
#if _DEBUG == 1
ocrGuid_t FUNC_debug(u32 paramc, u64* paramv, u32 depc, ocrEdtDep_t depv[])
{
    _UNUSED(paramc); _UNUSED(paramv); _UNUSED(depc);
    ///PRINTF("Starting FUNC_debug\n");
    struct bookkeeping* book = depv[1].ptr; //Grab the current iteration.

    double potential = 0.0;
    double kinetic = 0.0;

    // Iterate over each cell.
    for(s64 i=0; i<book->cell_count; ++i)
    {
        // Grab data.
        struct cellType* cell = depv[i*2+2].ptr;
        struct cellType* move = depv[i*2+3].ptr;

        // Warning: the following code could hide the fact that their are
        // duplicates if something goes wrong in our code.

        // Iterate over cells by id assigning them back to the buffer we used
        // as input. This actually re-orders the input buffer by ID.
        for(s64 j=0; j<cell->count; ++j) {
            assert(cell->atoms[j].id < book->number_atoms+1);
            assert(cell->atoms[j].id > 0);
            #if _DEBUG == 1 && _DEBUG_FILE_WRITE == 1
            #error OCR MD no longer supports referencing global simulation space data.
            space.atoms[cell->atoms[j].id-1] = cell->atoms[j];
            #endif
            potential += 4.0*cell->epsilon*cell->atoms[j].potential;
            cell->atoms[j].potential = 0.0;
            kinetic += cell->atoms[j].kinetic;
        }

        // Do the same with the input buffer.
        for(s64 j=0; j<move->count; ++j) {
            assert(move->atoms[j].id < book->number_atoms+1);
            assert(move->atoms[j].id > 0);
            #if _DEBUG == 1 && _DEBUG_FILE_WRITE == 1
            #error OCR MD no longer supports referencing global simulation space data.
            space.atoms[move->atoms[j].id-1] = move->atoms[j];
            #endif
            potential += move->atoms[j].potential = 0.0;;
            move->atoms[j].potential = 0.0;
            kinetic += move->atoms[j].kinetic;
        }
    }

    // Only write on the given iteration interval.
    if(book->write_count == 0)
    {
        // Only print iteration if we want to.
        #if _DEBUG == 1 && _DEBUG_STDOUT == 1
        printf(" %6ld %10.2f %18.12f %18.12f %18.12f\n",
        book->iteration, book->iteration*book->timestep,
        (kinetic+potential)/book->number_atoms,
        potential/book->number_atoms,
        kinetic/book->number_atoms);
        #endif

        #if _DEBUG == 1 && _DEBUG_FILE_WRITE == 1
        // Write out to file.
        write_out(_debugHandle, &space, book->iteration, kinetic, potential);
        #endif

        //Reset the iteration.
        book->write_count = book->write_freq;
    }
    book->write_count--; // Count down.!

    //Reset our energies.

    (book->iteration)++; //increment the time step.

    return NULL_GUID;
}
#endif

/*
    Schedules the tasks for an iteration dynamically.

    depv[0] : finishEDT dependency (for control dependencies).
    depv[1] : the current iteration (time).
    depv[2] : list of cells.
    depv[3] : list of move buffers.
*/
ocrGuid_t FUNC_timestep(u32 paramc, u64* paramv, u32 depc, ocrEdtDep_t depv[])
{
    _UNUSED(paramc); _UNUSED(paramv); _UNUSED(depc);
    ///PRINTF("Starting FUNC_timestep\n");

    // Grab data.
    ocrGuid_t DB_bookkeeping       = depv[1].guid; // book keeping info.
    ocrGuid_t DB_cell_list         = depv[2].guid; // list of cells.
    ocrGuid_t DB_move_list         = depv[3].guid; // list of move buffers.
    ocrGuid_t DB_templates         = depv[4].guid; // list of template GUIDs.
    struct bookkeeping* book       = depv[1].ptr;
    struct dbList* cell_list       = depv[2].ptr;
    struct dbList* move_list       = depv[3].ptr;
    struct templateType* TEMPLATE  = depv[4].ptr;

    // GUIDs for each EDT.
    ocrGuid_t EDT_spawnMomPos;
    ocrGuid_t EDT_spawnGather;
    ocrGuid_t EDT_spawnFor;
    ocrGuid_t EDT_spawnMom;
    ocrGuid_t EDT_timestep;
    #if _DEBUG == 1
    ocrGuid_t EDT_debug;
    #endif

    // GUIDs for each finish EDT event (for control dependencies).
    ocrGuid_t EVENT_momPosFinish;
    ocrGuid_t EVENT_gatherFinish;
    ocrGuid_t EVENT_forFinish;
    ocrGuid_t EVENT_momFinish;
    #if _DEBUG == 1
    ocrGuid_t EVENT_debugFinish;
    #endif

    // Check if the simulation should stop.
    if (book->iteration >= (book->num_timesteps+1)) // plus 1 because we stop at iteration after the last time step.
    {
        // Done simulation
        #if _DEBUG == 1 && _DEBUG_FILE_WRITE == 1
        fclose(_debugHandle);
        #endif
        ocrShutdown();
    }
    else if (book->iteration == book->initial_iteration) /* Time initial is special, we only compute initial forces here. */
    {
        /// Overall conceptual diagram of problem ordering:
        /// force --> timestep

        // Compute initial forces phase.

        // Create spawner for force computations.
        ocrEdtCreate(&EDT_spawnFor, TEMPLATE->spawnFor, EDT_PARAM_DEF,
                     /*paramv=*/NULL, EDT_PARAM_DEF, /*depv=*/NULL,
                     /*properties=*/ EDT_PROP_FINISH, NULL_GUID,
                     /*outEvent=*/&EVENT_forFinish);

        #if _DEBUG == 1
        // Create debug EDT to record output.
        ocrEdtCreate(&EDT_debug, TEMPLATE->debug, EDT_PARAM_DEF,
                     /*paramv=*/NULL, EDT_PARAM_DEF, /*depv=*/NULL,
                     /*properties=*/ EDT_PROP_FINISH, NULL_GUID,
                     /*outEvent=*/&EVENT_debugFinish);
        #endif

        // Create spawner for next time step.
        ocrEdtCreate(&EDT_timestep, TEMPLATE->timestep, EDT_PARAM_DEF,
                     /*paramv=*/NULL, EDT_PARAM_DEF, /*depv=*/NULL,
                     /*properties=*/ NULL_GUID, NULL_GUID,
                     /*outEvent=*/NULL);

        // Satisfy spawnFor EDT dependencies.
        ocrAddDependence(NULL_GUID,      EDT_spawnFor, 0, DB_MODE_RO);
        ocrAddDependence(DB_cell_list,   EDT_spawnFor, 1, DB_MODE_RO);
        ocrAddDependence(DB_templates,   EDT_spawnFor, 2, DB_MODE_RO);
        ocrAddDependence(DB_bookkeeping, EDT_spawnFor, 3, DB_MODE_RO); /*for periodicity information*/

        #if _DEBUG == 1
        // Satisfy spawnDebug EDT dependencies.
        ocrAddDependence(EVENT_forFinish, EDT_debug, 0, DB_MODE_RO);
        ocrAddDependence(DB_bookkeeping,  EDT_debug, 1, DB_MODE_ITW); // incremented.
        for(s64 i=0; i<book->cell_count; ++i)
        {
            ocrAddDependence(cell_list->db[i], EDT_debug, i*2+2, DB_MODE_RO);
            ocrAddDependence(move_list->db[i], EDT_debug, i*2+3, DB_MODE_RO);
        }

        // Satisfy timestep EDT dependencies.
        ocrAddDependence(EVENT_debugFinish, EDT_timestep, 0, DB_MODE_RO);
        ocrAddDependence(DB_bookkeeping,    EDT_timestep, 1, DB_MODE_ITW); // incremented.
        ocrAddDependence(DB_cell_list,      EDT_timestep, 2, DB_MODE_RO);
        ocrAddDependence(DB_move_list,      EDT_timestep, 3, DB_MODE_RO);
        ocrAddDependence(DB_templates,      EDT_timestep, 4, DB_MODE_RO);
        ///Don't increment time here. The debug step is responsible for it in debug builds!
        #else
        // Satisfy timestep EDT dependencies.
        ocrAddDependence(EVENT_forFinish, EDT_timestep, 0, DB_MODE_RO);
        ocrAddDependence(DB_bookkeeping,  EDT_timestep, 1, DB_MODE_ITW); // incremented.
        ocrAddDependence(DB_cell_list,    EDT_timestep, 2, DB_MODE_RO);
        ocrAddDependence(DB_move_list,    EDT_timestep, 3, DB_MODE_RO);
        ocrAddDependence(DB_templates,    EDT_timestep, 4, DB_MODE_RO);
        book->iteration++; // Increment time.
        #endif
    }
    else
    {
        /// Overall conceptual diagram of problem ordering:
        /// momentum/position --> gather --> force --> momentum --> timestep
        // normal timestep.

        // Create spawner for momentum/position computations.
        ocrEdtCreate(&EDT_spawnMomPos, TEMPLATE->spawnMomPos, EDT_PARAM_DEF,
                     /*paramv=*/NULL, EDT_PARAM_DEF, /*depv=*/NULL,
                     /*properties=*/ EDT_PROP_FINISH, NULL_GUID,
                     /*outEvent=*/&EVENT_momPosFinish);

        // Create spawner for gather computations.
        ocrEdtCreate(&EDT_spawnGather, TEMPLATE->spawnGather, EDT_PARAM_DEF,
                     /*paramv=*/NULL, EDT_PARAM_DEF, /*depv=*/NULL,
                     /*properties=*/ EDT_PROP_FINISH, NULL_GUID,
                     /*outEvent=*/&EVENT_gatherFinish);

        // Create spawner for force computations.
        ocrEdtCreate(&EDT_spawnFor, TEMPLATE->spawnFor, EDT_PARAM_DEF,
                     /*paramv=*/NULL, EDT_PARAM_DEF, /*depv=*/NULL,
                     /*properties=*/ EDT_PROP_FINISH, NULL_GUID,
                     /*outEvent=*/&EVENT_forFinish);

        // Create spawner for momentum computations.
        ocrEdtCreate(&EDT_spawnMom, TEMPLATE->spawnMom, EDT_PARAM_DEF,
                     /*paramv=*/NULL, EDT_PARAM_DEF, /*depv=*/NULL,
                     /*properties=*/ EDT_PROP_FINISH, NULL_GUID,
                     /*outEvent=*/&EVENT_momFinish);

        #if _DEBUG == 1
        // Create debug EDT.
        ocrEdtCreate(&EDT_debug, TEMPLATE->debug, EDT_PARAM_DEF,
                     /*paramv=*/NULL, EDT_PARAM_DEF, /*depv=*/NULL,
                     /*properties=*/ EDT_PROP_FINISH, NULL_GUID,
                     /*outEvent=*/&EVENT_debugFinish);
        #endif

        // Create spawner for next time step.
        ocrEdtCreate(&EDT_timestep, TEMPLATE->timestep, EDT_PARAM_DEF,
                     /*paramv=*/NULL, EDT_PARAM_DEF, /*depv=*/NULL,
                     /*properties=*/ NULL_GUID, NULL_GUID,
                     /*outEvent=*/NULL);

        // Satisfy spawnMomPos EDT dependencies.
        ocrAddDependence(NULL_GUID,    EDT_spawnMomPos, 0, DB_MODE_RO);
        ocrAddDependence(DB_cell_list, EDT_spawnMomPos, 1, DB_MODE_RO);
        ocrAddDependence(DB_move_list, EDT_spawnMomPos, 2, DB_MODE_RO);
        ocrAddDependence(DB_templates, EDT_spawnMomPos, 3, DB_MODE_RO);

        // Satisfy spawnGather EDT dependencies.
        ocrAddDependence(EVENT_momPosFinish, EDT_spawnGather, 0, DB_MODE_RO);
        ocrAddDependence(DB_cell_list, EDT_spawnGather, 1, DB_MODE_RO);
        ocrAddDependence(DB_move_list, EDT_spawnGather, 2, DB_MODE_RO);
        ocrAddDependence(DB_templates, EDT_spawnGather, 3, DB_MODE_RO);

        // Satisfy spawnFor EDT dependencies.
        ocrAddDependence(EVENT_gatherFinish, EDT_spawnFor, 0, DB_MODE_RO);
        ocrAddDependence(DB_cell_list,       EDT_spawnFor, 1, DB_MODE_RO);
        ocrAddDependence(DB_templates,       EDT_spawnFor, 2, DB_MODE_RO);
        ocrAddDependence(DB_bookkeeping,     EDT_spawnFor, 3, DB_MODE_RO); /*for periodicity information*/

        // Satisfy spawnMom EDT dependencies.
        ocrAddDependence(EVENT_forFinish, EDT_spawnMom, 0, DB_MODE_RO);
        ocrAddDependence(DB_cell_list,    EDT_spawnMom, 1, DB_MODE_RO);
        ocrAddDependence(DB_templates,    EDT_spawnMom, 2, DB_MODE_RO);

        #if _DEBUG == 1
        // Satisfy spawnDebug EDT dependencies.
        ocrAddDependence(EVENT_momFinish, EDT_debug, 0, DB_MODE_RO);
        ocrAddDependence(DB_bookkeeping,  EDT_debug, 1, DB_MODE_ITW); // incremented.
        for(s64 i=0; i<book->cell_count; ++i)
        {
            ocrAddDependence(cell_list->db[i], EDT_debug, i*2+2, DB_MODE_RO);
            ocrAddDependence(move_list->db[i], EDT_debug, i*2+3, DB_MODE_RO);
        }

        // Satisfy timestep EDT dependencies.
        ocrAddDependence(EVENT_debugFinish, EDT_timestep, 0, DB_MODE_RO);
        ocrAddDependence(DB_bookkeeping,    EDT_timestep, 1, DB_MODE_ITW); // incremented.
        ocrAddDependence(DB_cell_list,      EDT_timestep, 2, DB_MODE_RO);
        ocrAddDependence(DB_move_list,      EDT_timestep, 3, DB_MODE_RO);
        ocrAddDependence(DB_templates,      EDT_timestep, 4, DB_MODE_RO);
        /// Don't increment time here. The debug step is responsible for it in debug builds!
        #else
        // Satisfy timestep EDT dependencies.
        ocrAddDependence(EVENT_momFinish, EDT_timestep, 0, DB_MODE_RO);
        ocrAddDependence(DB_bookkeeping,  EDT_timestep, 1, DB_MODE_ITW); // incremented.
        ocrAddDependence(DB_cell_list,    EDT_timestep, 2, DB_MODE_RO);
        ocrAddDependence(DB_move_list,    EDT_timestep, 3, DB_MODE_RO);
        ocrAddDependence(DB_templates,    EDT_timestep, 4, DB_MODE_RO);
        book->iteration++; // increment time.
        #endif
    }

    return NULL_GUID;
}

/*
    1) Reads the input files and does initialization.
    2) Allocates datablocks for cells and move buffers, and iteration.
    3) Spawns initial timestep EDT.
*/
ocrGuid_t mainEdt(u32 paramc, u64* paramv, u32 depc, ocrEdtDep_t depv[])
{
    _UNUSED(paramc); _UNUSED(paramv); _UNUSED(depc);
    ///PRINTF("Starting mainEdt\n");

    //holds lamps input state information (and atoms).
    simulation_space space;

    // Check command line argument count.
    if(getArgc(depv[0].ptr) != 3)
    {
        printf("Usage:\n\tmdd <cell dimensions> <filename without extension>\n");
        ocrShutdown();
        return NULL_GUID;
    }

    /*********************/
    /// Read command line arguments.
    //Read cell count.
    s64 cell_per_dims = strtol(getArgv(depv[0].ptr, 1), NULL, 10);
    s64 cell_count = cell_per_dims*cell_per_dims*cell_per_dims;
    //Read file prefix.
    char* filename_prefix = getArgv(depv[0].ptr, 2);
    /*********************/

    /*********************/
    ///Read inputs and initialize things.
    char filename[1024];
    // Read files.
    sprintf(filename, "input/%s.in", filename_prefix);
    printf("Reading file '%s'...\n", filename);
    read_file(filename, &space); // Read our input file of atoms.
    sprintf(filename, "input/%s.lammps", filename_prefix);
    printf("Reading file '%s'...\n", filename);
    read_lammps(filename, &space); // Read our lammps file for some configuration parameters.
    double x_cell_size = ((space.hi.x - space.lo.x)/(double)cell_per_dims);
    double y_cell_size = ((space.hi.y - space.lo.y)/(double)cell_per_dims);
    double z_cell_size = ((space.hi.z - space.lo.z)/(double)cell_per_dims);
    /*********************/

    /*********************/
    /// Write file.
    #if _DEBUG == 1 && _DEBUG_FILE_WRITE == 1
    sprintf(filename, "output/%s.ocr", filename_prefix);
    printf("Writing debug output to file '%s'...\n", filename);
    _debugHandle = fopen(filename, "w");
    #endif
    /*********************/

    /*********************/
    /// Write info to terminal.
    printf("Starting simulation at time = %ld.\n", space.initial_iteration);
    printf("Using %ld by %ld by %ld cells.\n", cell_per_dims, cell_per_dims, cell_per_dims);
    assert(cell_per_dims > 0);
    printf("Using x dimensions %f by %f.\n", space.lo.x, space.hi.x);
    printf("Using y dimensions %f by %f.\n", space.lo.y, space.hi.y);
    printf("Using z dimensions %f by %f.\n", space.lo.z, space.hi.z);
    printf("Using x cell size of %f.\n", x_cell_size);
    printf("Using y cell size of %f.\n", y_cell_size);
    printf("Using z cell size of %f.\n", z_cell_size);
    printf("Using timestep = %g.\n", space.timestep);
    assert(space.timestep > 0.0);
    printf("Using number of timesteps = %ld.\n", space.num_timesteps);
    assert(space.num_timesteps > 0);
    printf("Using write frequency = %ld.\n", space.write_freq);
    assert(space.write_freq > 0);
    printf("Using cutoff = %g.\n", space.cutoff);
    assert(space.cutoff > 0);
    printf("Using epsilon = %g.\n", space.epsilon);
    assert(space.epsilon > 0);
    printf("Using sigma = %g.\n", space.sigma);
    assert(space.sigma > 0);
    #if _DEBUG == 1 && _DEBUG_STDOUT == 1
    printf("#  Loop   Time(fs)       Total Energy   Potential Energy     Kinetic Energy\n");
    #endif
    /*********************/

    // Sanity -- cutoff needs to be smaller than 2 times the space otherwise, periodic boundary conditions can break.
    assert(space.cutoff < 2.0*(space.hi.x - space.lo.x));

    // Sanity -- boxes need to be bigger than the cutoff or the computation is wrong.
    assert(space.cutoff<=x_cell_size);
    assert(space.cutoff<=y_cell_size);
    assert(space.cutoff<=z_cell_size);

    #if _OCR_IS_BROKEN == 1
    /**************************************************************************/
    // Work around since exclusive writes aren't implemented. -_- ...
    FOO_MUTEX = malloc(sizeof(pthread_mutex_t)*cell_count);
    for(s64 i=0; i<cell_count; ++i)
        pthread_mutex_init (&FOO_MUTEX[i], NULL);
    /**************************************************************************/
    #endif

    /// Allocate stuffs.

    /*********************/
    /// DB to hold the current iteration.
    struct bookkeeping* book;
    ocrGuid_t DB_bookkeeping;
    ocrDbCreate(&DB_bookkeeping,(void **) &book,
                sizeof(struct bookkeeping), DB_PROP_NONE, NULL_GUID, NO_ALLOC);
    book->timestep          = space.timestep;          // assign timestep interval.
    book->num_timesteps     = space.num_timesteps;     // total number of timesteps.
    book->initial_iteration = space.initial_iteration; // start iteration.
    book->iteration         = space.initial_iteration; // assign the current time.
    book->number_atoms      = space.number_atoms;      // count of problem atoms.
    book->cell_count        = cell_count;              //assign cell total count.
    book->cell_per_dims     = cell_per_dims;           //assign per dimension cell count.
    book->x_period          = space.period_x;
    book->y_period          = space.period_y;
    book->z_period          = space.period_z;

    #if _DEBUG == 1
    #if _DEBUG_FILE_WRITE == 1 || _DEBUG_STDOUT == 1
    book->write_freq = space.write_freq; //frequency to display output.
    book->write_count = 0;               // write count interval.
    #endif
    #endif
    /***********************/

    /*********************/
    /// DB to hold templates for EDT creation.
    struct templateType* TEMPLATE;
    ocrGuid_t DB_templates;
    ocrDbCreate(&DB_templates,(void **) &TEMPLATE,
                sizeof(struct templateType), DB_PROP_NONE, NULL_GUID, NO_ALLOC);
    /***********************/

    /*********************/
    /// Allocate DBs for dealing with cells...

    // Allocate DB to store the GUIDs of the cells.
    // Used to pass the GUID information to other EDTs.
    ocrGuid_t DB_cell_list; //datablock that holds DB guids for cells.
    struct dbList* cell_list;
    ocrDbCreate(&DB_cell_list,(void **) &cell_list, sizeof(struct dbList) +
                sizeof(ocrGuid_t)*cell_count, DB_PROP_NONE, NULL_GUID, NO_ALLOC);
    cell_list->count = cell_count;

    // Allocate Cell space to store atoms.
    struct cellType* cells[cell_count];
    for(s64 i=0; i<cell_count; ++i)
    {
        struct cellType* cell;
        // Allocate individual cell memory.
        ocrDbCreate(&cell_list->db[i],(void **) &cell,
                    sizeof(struct cellType) +
                    sizeof(struct atomType)*CELL_SIZE,
                    DB_PROP_NONE, NULL_GUID, NO_ALLOC);
        cells[i] = cell;

        //Set x, y, z coors.
        cell->x_coor = GET_X(i, cell_per_dims);
        cell->y_coor = GET_Y(i, cell_per_dims);
        cell->z_coor = GET_Z(i, cell_per_dims);

        //Compute high and low boundaries for the space.
        cell->x_lo = space.lo.x;
        cell->y_lo = space.lo.y;
        cell->z_lo = space.lo.z;
        cell->x_hi = space.hi.x;
        cell->y_hi = space.hi.y;
        cell->z_hi = space.hi.z;
        //Assign problem constants to each cell (for compatibility with distributed OCR).
        cell->x_period     = space.period_x;
        cell->y_period     = space.period_y;
        cell->z_period     = space.period_z;
        cell->timestep     = space.timestep;
        cell->sigma        = space.sigma;
        cell->epsilon      = space.epsilon;
        cell->cutoff       = space.cutoff;
        cell->cell_count   = cell_count;
        cell->id = i;                        //assign an index to the cell.
        cell->count = 0;                     //zero out the atom count.
        cell->cell_count = cell_count;       //assign total cell count;
        cell->cell_per_dims = cell_per_dims; //assign per dimension cell count.

        /// Make sure the logic for getting the coordinates from id is reversible.
        assert(cell->x_coor + cell->y_coor * cell_per_dims + cell->z_coor * cell_per_dims * cell_per_dims == i);
    }
    /***********************/
    /// Allocate DBs for dealing with move buffers...

    // Allocate DB to store the GUIDs of moved atoms.
    // Used to pass the GUID information to other EDTs.
    ocrGuid_t DB_move_list; //datablock that holds DB guids for cells.
    struct dbList* move_list;
    ocrDbCreate(&DB_move_list,(void **) &move_list, sizeof(struct dbList) +
                sizeof(ocrGuid_t)*cell_count, DB_PROP_NONE, NULL_GUID, NO_ALLOC);
    move_list->count = cell_count;

    // Allocate move space to store atoms.
    for(s64 i=0; i<cell_count; ++i)
    {
        struct cellType* move;
        // Allocate individual cell memory.
        ocrDbCreate(&move_list->db[i],(void **) &move,
                    sizeof(struct cellType) + sizeof(struct atomType)*CELL_SIZE, DB_PROP_NONE, NULL_GUID, NO_ALLOC);
        move->id = i;    //assign an index to the cell.
        move->count = 0; //zero out the cell count.
    }
    /***********************/

    /***********************/
    /// Iterate over particles adding them to cells.
    for(s64 i=0; i<space.number_atoms; i++)
    {
        //Make sure we meet the boundary conditions.
        assert(space.atoms[i].pos_x<=space.hi.x);
        assert(space.atoms[i].pos_y<=space.hi.y);
        assert(space.atoms[i].pos_z<=space.hi.z);
        assert(space.atoms[i].pos_x>=space.lo.x);
        assert(space.atoms[i].pos_y>=space.lo.y);
        assert(space.atoms[i].pos_z>=space.lo.z);

        // Figure out where to place atoms..
        s64 x = (space.atoms[i].pos_x-(space.lo.x))/x_cell_size;
        s64 y = (space.atoms[i].pos_y-(space.lo.y))/y_cell_size;
        s64 z = (space.atoms[i].pos_z-(space.lo.z))/z_cell_size;

        //Sanity, make sure we aren't out of cell bounds.
        assert(x<cell_per_dims);
        assert(y<cell_per_dims);
        assert(z<cell_per_dims);

        //Assign atom to given cell.
        struct cellType* cell = cells[x+y*cell_per_dims+z*cell_per_dims*cell_per_dims];
        cell->atoms[cell->count] = space.atoms[i];
        cell->count++;

        if(cell->count>CELL_SIZE)
        {
            printf("Error, more than CELL_SIZE (%ld) atoms in a cell!\n", CELL_SIZE);
            ocrShutdown();
            return NULL_GUID;
        }
    }
    /***********************/

    // Create the task templates.
    ocrEdtTemplateCreate(&TEMPLATE->spawnMomPos, FUNC_spawnMomPos, 0 /*paramc*/, 4 /*depc*/);
    ocrEdtTemplateCreate(&TEMPLATE->calcMomPos, FUNC_calcMomPos, 0 /*paramc*/, 3 /*depc*/);
    ocrEdtTemplateCreate(&TEMPLATE->spawnGather, FUNC_spawnGather, 0 /*paramc*/, 4 /*depc*/);
    ocrEdtTemplateCreate(&TEMPLATE->gather, FUNC_gather, 0 /*paramc*/, 2 /*depc*/);
    ocrEdtTemplateCreate(&TEMPLATE->scatter, FUNC_scatter, 0 /*paramc*/, 2 /*depc*/);
    ocrEdtTemplateCreate(&TEMPLATE->spawnFor, FUNC_spawnFor, 0 /*paramc*/, 4 /*depc*/);
    ocrEdtTemplateCreate(&TEMPLATE->calcFor, FUNC_calcFor, 0 /*paramc*/, 27 /*depc*/);
    ocrEdtTemplateCreate(&TEMPLATE->spawnMom, FUNC_spawnMom, 0 /*paramc*/, 3 /*depc*/);
    ocrEdtTemplateCreate(&TEMPLATE->calcMom, FUNC_calcMom, 0 /*paramc*/, 1 /*depc*/);
    ocrEdtTemplateCreate(&TEMPLATE->timestep, FUNC_timestep, 0 /*paramc*/, 5 /*depc*/);

    #if _DEBUG == 1
    ocrEdtTemplateCreate(&TEMPLATE->debug, FUNC_debug, 0 /*paramc*/, (cell_count)*2+2 /*depc*/);
    #endif

    /**************************************************************************/
    /// Schedule timestep.

    // Create spawner for the first time step.
    ocrGuid_t EDT_timestep;
    ocrEdtCreate(&EDT_timestep, TEMPLATE->timestep, EDT_PARAM_DEF,
                 /*paramv=*/NULL, EDT_PARAM_DEF, /*depv=*/NULL,
                 /*properties=*/ NULL_GUID, NULL_GUID,
                 /*outEvent=*/NULL);

    //S atisfy timestep EDT dependencies.
    ocrAddDependence(NULL_GUID,      EDT_timestep, 0, DB_MODE_RO);
    ocrAddDependence(DB_bookkeeping, EDT_timestep, 1, DB_MODE_ITW); //incremented.
    ocrAddDependence(DB_cell_list,   EDT_timestep, 2, DB_MODE_RO);
    ocrAddDependence(DB_move_list,   EDT_timestep, 3, DB_MODE_RO);
    ocrAddDependence(DB_templates,   EDT_timestep, 4, DB_MODE_RO);
    /**************************************************************************/

    ///Free atom information.
    free(space.atoms);
    return NULL_GUID;
}
